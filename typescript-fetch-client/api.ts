/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Signal Server API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://chat.signal.org".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AccountAndDevicesDataReport
 */
export interface AccountAndDevicesDataReport {
    /**
     * 
     * @type {AccountDataReport}
     * @memberof AccountAndDevicesDataReport
     */
    account?: AccountDataReport;
    /**
     * 
     * @type {Array<DeviceDataReport>}
     * @memberof AccountAndDevicesDataReport
     */
    devices?: Array<DeviceDataReport>;
}
/**
 * 
 * @export
 * @interface AccountAttributes
 */
export interface AccountAttributes {
    /**
     * 
     * @type {boolean}
     * @memberof AccountAttributes
     */
    fetchesMessages?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountAttributes
     */
    registrationId?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountAttributes
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAttributes
     */
    registrationLock?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountAttributes
     */
    unidentifiedAccessKey?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountAttributes
     */
    unrestrictedUnidentifiedAccess?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccountAttributes
     */
    capabilities?: Array<AccountAttributes.CapabilitiesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof AccountAttributes
     */
    discoverableByPhoneNumber?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountAttributes
     */
    recoveryPassword?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountAttributes
     */
    eachRegistrationIdValid?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountAttributes
     */
    pniRegistrationId?: number;
}

/**
 * @export
 * @namespace AccountAttributes
 */
export namespace AccountAttributes {
    /**
     * @export
     * @enum {string}
     */
    export enum CapabilitiesEnum {
        STORAGE = <any> 'STORAGE',
        TRANSFER = <any> 'TRANSFER',
        DELETESYNC = <any> 'DELETE_SYNC',
        VERSIONEDEXPIRATIONTIMER = <any> 'VERSIONED_EXPIRATION_TIMER',
        STORAGESERVICERECORDKEYROTATION = <any> 'STORAGE_SERVICE_RECORD_KEY_ROTATION'
    }
}
/**
 * 
 * @export
 * @interface AccountDataReport
 */
export interface AccountDataReport {
    /**
     * 
     * @type {string}
     * @memberof AccountDataReport
     */
    phoneNumber?: string;
    /**
     * 
     * @type {Array<BadgeDataReport>}
     * @memberof AccountDataReport
     */
    badges?: Array<BadgeDataReport>;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDataReport
     */
    allowSealedSenderFromAnyone?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDataReport
     */
    findAccountByPhoneNumber?: boolean;
}
/**
 * 
 * @export
 * @interface AccountDataReportResponse
 */
export interface AccountDataReportResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountDataReportResponse
     */
    reportId?: string;
    /**
     * 
     * @type {Date}
     * @memberof AccountDataReportResponse
     */
    reportTimestamp?: Date;
    /**
     * 
     * @type {AccountAndDevicesDataReport}
     * @memberof AccountDataReportResponse
     */
    data?: AccountAndDevicesDataReport;
    /**
     * A plaintext representation of the data report
     * @type {string}
     * @memberof AccountDataReportResponse
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface AccountIdentifierResponse
 */
export interface AccountIdentifierResponse {
    /**
     * An identifier for an account based on the account's ACI
     * @type {string}
     * @memberof AccountIdentifierResponse
     */
    uuid: string;
}
/**
 * 
 * @export
 * @interface AccountIdentityResponse
 */
export interface AccountIdentityResponse {
    /**
     * the account identifier for this account
     * @type {string}
     * @memberof AccountIdentityResponse
     */
    uuid?: string;
    /**
     * the phone number associated with this account
     * @type {string}
     * @memberof AccountIdentityResponse
     */
    number?: string;
    /**
     * the account identifier for this account's phone-number identity
     * @type {string}
     * @memberof AccountIdentityResponse
     */
    pni?: string;
    /**
     * a hash of this account's username, if set
     * @type {string}
     * @memberof AccountIdentityResponse
     */
    usernameHash?: string;
    /**
     * this account's username link handle, if set
     * @type {string}
     * @memberof AccountIdentityResponse
     */
    usernameLinkHandle?: string;
    /**
     * whether any of this account's devices support storage
     * @type {boolean}
     * @memberof AccountIdentityResponse
     */
    storageCapable?: boolean;
    /**
     * 
     * @type {Entitlements}
     * @memberof AccountIdentityResponse
     */
    entitlements?: Entitlements;
}
/**
 * 
 * @export
 * @interface AccountMismatchedDevices
 */
export interface AccountMismatchedDevices {
    /**
     * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
     * @type {string}
     * @memberof AccountMismatchedDevices
     */
    uuid?: string;
    /**
     * 
     * @type {MismatchedDevices}
     * @memberof AccountMismatchedDevices
     */
    devices?: MismatchedDevices;
}
/**
 * 
 * @export
 * @interface AccountStaleDevices
 */
export interface AccountStaleDevices {
    /**
     * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
     * @type {string}
     * @memberof AccountStaleDevices
     */
    uuid?: string;
    /**
     * 
     * @type {StaleDevices}
     * @memberof AccountStaleDevices
     */
    devices?: StaleDevices;
}
/**
 * 
 * @export
 * @interface AciMonitor
 */
export interface AciMonitor {
    /**
     * An identifier for an account based on the account's ACI
     * @type {string}
     * @memberof AciMonitor
     */
    value: string;
    /**
     * A log tree position maintained by the client for the aci.
     * @type {number}
     * @memberof AciMonitor
     */
    entryPosition?: number;
    /**
     * The commitment index derived from a previous search request, encoded in standard unpadded base64
     * @type {string}
     * @memberof AciMonitor
     */
    commitmentIndex: string;
}
/**
 * An identifier for an account based on the account's ACI
 * @export
 * @interface AciServiceIdentifier
 */
export interface AciServiceIdentifier extends ServiceIdentifier {
}
/**
 * 
 * @export
 * @interface Anonymous
 */
export interface Anonymous {
    /**
     * 
     * @type {string}
     * @memberof Anonymous
     */
    accessKey?: string;
}
/**
 * 
 * @export
 * @interface AnswerCaptchaChallengeRequest
 */
export interface AnswerCaptchaChallengeRequest extends AnswerChallengeRequest {
    /**
     * The value of the token field from the server's 428 response
     * @type {string}
     * @memberof AnswerCaptchaChallengeRequest
     */
    token: string;
    /**
     * A string representing a solved captcha
     * @type {string}
     * @memberof AnswerCaptchaChallengeRequest
     */
    captcha: string;
}
/**
 * 
 * @export
 * @interface AnswerChallengeRequest
 */
export interface AnswerChallengeRequest {
    /**
     * 
     * @type {string}
     * @memberof AnswerChallengeRequest
     */
    type: string;
}
/**
 * 
 * @export
 * @interface AnswerPushChallengeRequest
 */
export interface AnswerPushChallengeRequest extends AnswerChallengeRequest {
    /**
     * A token provided to the client via a push payload
     * @type {string}
     * @memberof AnswerPushChallengeRequest
     */
    challenge: string;
}
/**
 * An APNs token set for the account's primary device. If provided, the account's primary device will be notified of new messages via push notifications to the given token. Callers must provide exactly one of an APNs token set, an FCM token, or an `AccountAttributes` entity with `fetchesMessages` set to `true`. 
 * @export
 * @interface ApnRegistrationId
 */
export interface ApnRegistrationId {
    /**
     * 
     * @type {string}
     * @memberof ApnRegistrationId
     */
    apnRegistrationId: string;
}
/**
 * 
 * @export
 * @interface AssertionRequest
 */
export interface AssertionRequest {
    /**
     * The challenge retrieved at `GET /v1/devicecheck/assert`
     * @type {string}
     * @memberof AssertionRequest
     */
    challenge?: string;
    /**
     * The type of action you'd like to perform with this assert
     * @type {string}
     * @memberof AssertionRequest
     */
    action?: AssertionRequest.ActionEnum;
}

/**
 * @export
 * @namespace AssertionRequest
 */
export namespace AssertionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        Backup = <any> 'backup'
    }
}
/**
 * 
 * @export
 * @interface AttachmentDescriptorV3
 */
export interface AttachmentDescriptorV3 {
    /**
     * Indicates the CDN type. 2 in the v3 API, 2 or 3 in the v4 API. 2 indicates resumable uploads using GCS, 3 indicates resumable uploads using TUS 
     * @type {number}
     * @memberof AttachmentDescriptorV3
     */
    cdn?: number;
    /**
     * The location within the specified cdn where the finished upload can be found
     * @type {string}
     * @memberof AttachmentDescriptorV3
     */
    key?: string;
    /**
     * A map of headers to include with all upload requests. Potentially contains time-limited upload credentials
     * @type {{ [key: string]: string; }}
     * @memberof AttachmentDescriptorV3
     */
    headers?: { [key: string]: string; };
    /**
     * The URL to upload to with the appropriate protocol
     * @type {string}
     * @memberof AttachmentDescriptorV3
     */
    signedUploadLocation?: string;
}
/**
 * 
 * @export
 * @interface AuthCheckRequest
 */
export interface AuthCheckRequest {
    /**
     * The e164-formatted phone number.
     * @type {string}
     * @memberof AuthCheckRequest
     */
    number: string;
    /**
     * A list of SVR tokens, previously retrieved from `backup/auth`. Tokens should be the of the form \"username:password\". May contain at most 10 tokens.
     * @type {Array<string>}
     * @memberof AuthCheckRequest
     */
    tokens: Array<string>;
}
/**
 * 
 * @export
 * @interface AuthCheckResponseV2
 */
export interface AuthCheckResponseV2 {
    /**
     * A dictionary with the auth check results: `SVR Credentials -> 'match'/'no-match'/'invalid'`
     * @type {{ [key: string]: string; }}
     * @memberof AuthCheckResponseV2
     */
    matches: { [key: string]: string; };
}

/**
 * @export
 * @namespace AuthCheckResponseV2
 */
export namespace AuthCheckResponseV2 {
    /**
     * @export
     * @enum {string}
     */
    export enum MatchesEnum {
        Match = <any> 'match',
        NoMatch = <any> 'no-match',
        Invalid = <any> 'invalid'
    }
}
/**
 * A map of credential types to lists of BackupAuthCredentials and their validity periods
 * @export
 * @interface BackupAuthCredential
 */
export interface BackupAuthCredential {
    /**
     * A BackupAuthCredential, encoded in standard padded base64
     * @type {string}
     * @memberof BackupAuthCredential
     */
    credential?: string;
    /**
     * The day on which this credential is valid. Seconds since epoch truncated to day boundary
     * @type {number}
     * @memberof BackupAuthCredential
     */
    redemptionTime?: number;
}
/**
 * 
 * @export
 * @interface BackupAuthCredentialsResponse
 */
export interface BackupAuthCredentialsResponse {
    /**
     * A map of credential types to lists of BackupAuthCredentials and their validity periods
     * @type {{ [key: string]: Array<BackupAuthCredential>; }}
     * @memberof BackupAuthCredentialsResponse
     */
    credentials?: { [key: string]: Array<BackupAuthCredential>; };
}
/**
 * Backup specific configuration
 * @export
 * @interface BackupConfiguration
 */
export interface BackupConfiguration {
    /**
     * A map of numeric backup level IDs to level-specific backup configuration
     * @type {{ [key: string]: BackupLevelConfiguration; }}
     * @memberof BackupConfiguration
     */
    levels?: { [key: string]: BackupLevelConfiguration; };
    /**
     * The number of days of media a free tier backup user gets
     * @type {number}
     * @memberof BackupConfiguration
     */
    freeTierMediaDays?: number;
}
/**
 * If present, the backup level set via /v1/archives/redeem-receipt
 * @export
 * @interface BackupEntitlement
 */
export interface BackupEntitlement {
    /**
     * The backup level of the account
     * @type {number}
     * @memberof BackupEntitlement
     */
    backupLevel?: number;
    /**
     * When the backup entitlement expires, in number of seconds since epoch
     * @type {number}
     * @memberof BackupEntitlement
     */
    expirationSeconds?: number;
}
/**
 * 
 * @export
 * @interface BackupInfoResponse
 */
export interface BackupInfoResponse {
    /**
     * The CDN type where the message backup is stored. Media may be stored elsewhere.
     * @type {number}
     * @memberof BackupInfoResponse
     */
    cdn?: number;
    /**
     * The base directory of your backup data on the cdn. The message backup can be found in the returned cdn at /backupDir/backupName and stored media can be found at /backupDir/mediaDir/mediaId 
     * @type {string}
     * @memberof BackupInfoResponse
     */
    backupDir?: string;
    /**
     * The prefix path component for media objects on a cdn. Stored media for mediaId can be found at /backupDir/mediaDir/mediaId. 
     * @type {string}
     * @memberof BackupInfoResponse
     */
    mediaDir?: string;
    /**
     * The name of the most recent message backup on the cdn. The backup is at /backupDir/backupName
     * @type {string}
     * @memberof BackupInfoResponse
     */
    backupName?: string;
    /**
     * The amount of space used to store media
     * @type {number}
     * @memberof BackupInfoResponse
     */
    usedSpace?: number;
}
/**
 * Configuration for a backup level - use to present appropriate client interfaces
 * @export
 * @interface BackupLevelConfiguration
 */
export interface BackupLevelConfiguration {
    /**
     * The amount of media storage in bytes that a paying subscriber may store
     * @type {number}
     * @memberof BackupLevelConfiguration
     */
    storageAllowanceBytes?: number;
    /**
     * The play billing productID associated with this backup level
     * @type {string}
     * @memberof BackupLevelConfiguration
     */
    playProductId?: string;
    /**
     * The duration, in days, for which your backed up media is retained on the server after you stop refreshing with a paid credential
     * @type {number}
     * @memberof BackupLevelConfiguration
     */
    mediaTtlDays?: number;
}
/**
 * The displayable badge associated with the level
 * @export
 * @interface Badge
 */
export interface Badge {
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Badge
     */
    sprites6?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    svg?: string;
    /**
     * 
     * @type {Array<BadgeSvg>}
     * @memberof Badge
     */
    svgs?: Array<BadgeSvg>;
    /**
     * 
     * @type {string}
     * @memberof Badge
     */
    imageUrl?: string;
}
/**
 * 
 * @export
 * @interface BadgeDataReport
 */
export interface BadgeDataReport {
    /**
     * 
     * @type {string}
     * @memberof BadgeDataReport
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof BadgeDataReport
     */
    expiration?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BadgeDataReport
     */
    visible?: boolean;
}
/**
 * Active badges added via /v1/donation/redeem-receipt
 * @export
 * @interface BadgeEntitlement
 */
export interface BadgeEntitlement {
    /**
     * The badge id
     * @type {string}
     * @memberof BadgeEntitlement
     */
    id?: string;
    /**
     * Whether the badge is currently configured to be visible
     * @type {boolean}
     * @memberof BadgeEntitlement
     */
    visible?: boolean;
    /**
     * When the badge expires, in number of seconds since epoch
     * @type {number}
     * @memberof BadgeEntitlement
     */
    expirationSeconds?: number;
}
/**
 * 
 * @export
 * @interface BadgeSvg
 */
export interface BadgeSvg {
    /**
     * 
     * @type {string}
     * @memberof BadgeSvg
     */
    light: string;
    /**
     * 
     * @type {string}
     * @memberof BadgeSvg
     */
    dark: string;
}
/**
 * 
 * @export
 * @interface BaseProfileResponse
 */
export interface BaseProfileResponse {
    /**
     * 
     * @type {IdentityKey}
     * @memberof BaseProfileResponse
     */
    identityKey?: IdentityKey;
    /**
     * 
     * @type {string}
     * @memberof BaseProfileResponse
     */
    unidentifiedAccess?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseProfileResponse
     */
    unrestrictedUnidentifiedAccess?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof BaseProfileResponse
     */
    capabilities?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<Badge>}
     * @memberof BaseProfileResponse
     */
    badges?: Array<Badge>;
    /**
     * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
     * @type {string}
     * @memberof BaseProfileResponse
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface BasicAuthorizationHeader
 */
export interface BasicAuthorizationHeader {
    /**
     * 
     * @type {string}
     * @memberof BasicAuthorizationHeader
     */
    username?: string;
    /**
     * 
     * @type {number}
     * @memberof BasicAuthorizationHeader
     */
    deviceId?: number;
    /**
     * 
     * @type {string}
     * @memberof BasicAuthorizationHeader
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface BatchIdentityCheckRequest
 */
export interface BatchIdentityCheckRequest {
    /**
     * 
     * @type {Array<Element>}
     * @memberof BatchIdentityCheckRequest
     */
    elements: Array<Element>;
}
/**
 * 
 * @export
 * @interface BatchIdentityCheckResponse
 */
export interface BatchIdentityCheckResponse {
    /**
     * 
     * @type {Array<Element>}
     * @memberof BatchIdentityCheckResponse
     */
    elements?: Array<Element>;
}
/**
 * 
 * @export
 * @interface CallLinkAuthCredential
 */
export interface CallLinkAuthCredential {
    /**
     * 
     * @type {string}
     * @memberof CallLinkAuthCredential
     */
    credential?: string;
    /**
     * 
     * @type {number}
     * @memberof CallLinkAuthCredential
     */
    redemptionTime?: number;
}
/**
 * 
 * @export
 * @interface ChallengeResponse
 */
export interface ChallengeResponse {
    /**
     * A challenge to use when generating attestations or assertions
     * @type {string}
     * @memberof ChallengeResponse
     */
    challenge?: string;
}
/**
 * 
 * @export
 * @interface ChangeNumberRequest
 */
export interface ChangeNumberRequest {
    /**
     * A session ID from registration service, if using session id to authenticate this request. Must not be combined with `recoveryPassword`.
     * @type {string}
     * @memberof ChangeNumberRequest
     */
    sessionId?: string;
    /**
     * The base64-encoded recovery password for the new phone number, if using a recovery password to authenticate this request. Must not be combined with `sessionId`.
     * @type {string}
     * @memberof ChangeNumberRequest
     */
    recoveryPassword?: string;
    /**
     * the new phone number for this account
     * @type {string}
     * @memberof ChangeNumberRequest
     */
    number: string;
    /**
     * 
     * @type {IdentityKey}
     * @memberof ChangeNumberRequest
     */
    pniIdentityKey: IdentityKey;
    /**
     * A list of synchronization messages to send to companion devices to supply the private keysManager associated with the new identity key and their new prekeys. Exactly one message must be supplied for each enabled device other than the sending (primary) device.
     * @type {Array<IncomingMessage>}
     * @memberof ChangeNumberRequest
     */
    deviceMessages: Array<IncomingMessage>;
    /**
     * A new signed elliptic-curve prekey for each enabled device on the account, including this one. Each must be accompanied by a valid signature from the new identity key in this request.
     * @type {{ [key: string]: ECSignedPreKey; }}
     * @memberof ChangeNumberRequest
     */
    devicePniSignedPrekeys: { [key: string]: ECSignedPreKey; };
    /**
     * A new signed post-quantum last-resort prekey for each enabled device on the account, including this one. May be absent, in which case the last resort PQ prekeys for each device will be deleted if any had been stored. If present, must contain one prekey per enabled device including this one. Prekeys for devices that did not previously have any post-quantum prekeys stored will be silently dropped. Each must be accompanied by a valid signature from the new identity key in this request.
     * @type {{ [key: string]: KEMSignedPreKey; }}
     * @memberof ChangeNumberRequest
     */
    devicePniPqLastResortPrekeys?: { [key: string]: KEMSignedPreKey; };
    /**
     * the new phone-number-identity registration ID for each enabled device on the account, including this one
     * @type {{ [key: string]: number; }}
     * @memberof ChangeNumberRequest
     */
    pniRegistrationIds: { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof ChangeNumberRequest
     */
    eachPniRegistrationIdValid?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChangeNumberRequest
     */
    valid?: boolean;
    /**
     * the registration lock password for the new phone number, if necessary
     * @type {string}
     * @memberof ChangeNumberRequest
     */
    reglock?: string;
}
/**
 *   Meaningfully interpreting chargeFailure response fields requires inspecting the processor field first.    For Stripe, code will be one of the [codes defined here](https://stripe.com/docs/api/charges/object#charge_object-failure_code),   while message [may contain a further textual description](https://stripe.com/docs/api/charges/object#charge_object-failure_message).   The outcome fields are nullable, but present values will directly map to Stripe [response properties](https://stripe.com/docs/api/charges/object#charge_object-outcome-network_status)    For Braintree, the outcome fields will be null. The code and message will contain one of     - a processor decline code (as a string) in code, and associated text in message, as defined this [table](https://developer.paypal.com/braintree/docs/reference/general/processor-responses/authorization-responses)     - `gateway` in code, with a [reason](https://developer.paypal.com/braintree/articles/control-panel/transactions/gateway-rejections) in message     - `code` = \"unknown\", message = \"unknown\"    IAP payment processors will never include charge failure information, and detailed order information should be   retrieved from the payment processor directly 
 * @export
 * @interface ChargeFailure
 */
export interface ChargeFailure {
    /**
     * See [Stripe failure codes](https://stripe.com/docs/api/charges/object#charge_object-failure_code) or [Braintree decline codes](https://developer.paypal.com/braintree/docs/reference/general/processor-responses/authorization-responses#decline-codes) depending on which processor was used 
     * @type {string}
     * @memberof ChargeFailure
     */
    code?: string;
    /**
     * See [Stripe failure codes](https://stripe.com/docs/api/charges/object#charge_object-failure_code) or [Braintree decline codes](https://developer.paypal.com/braintree/docs/reference/general/processor-responses/authorization-responses#decline-codes) depending on which processor was used 
     * @type {string}
     * @memberof ChargeFailure
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeFailure
     */
    outcomeNetworkStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeFailure
     */
    outcomeReason?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargeFailure
     */
    outcomeType?: string;
}
/**
 * 
 * @export
 * @interface CheckKeysRequest
 */
export interface CheckKeysRequest {
    /**
     * The identity type for which to check for a shared view of repeated-use keys 
     * @type {string}
     * @memberof CheckKeysRequest
     */
    identityType: CheckKeysRequest.IdentityTypeEnum;
    /**
     * A 32-byte digest of the client's repeated-use keys for the given identity type. The digest is calculated as:  SHA256(identityKeyBytes || signedEcPreKeyId || signedEcPreKeyIdBytes || lastResortKeyId || lastResortKeyBytes)  …where the elements of the hash are:  - identityKeyBytes: the serialized form of the client's public identity key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - signedEcPreKeyId: an 8-byte, big-endian representation of the ID of the client's signed EC pre-key - signedEcPreKeyBytes: the serialized form of the client's signed EC pre-key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - lastResortKeyId: an 8-byte, big-endian representation of the ID of the client's last-resort Kyber key - lastResortKeyBytes: the serialized form of the client's last-resort Kyber key as produced by libsignal (i.e.   one version byte followed by 1568 bytes of key material for a total of 1569 bytes) 
     * @type {string}
     * @memberof CheckKeysRequest
     */
    digest: string;
}

/**
 * @export
 * @namespace CheckKeysRequest
 */
export namespace CheckKeysRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum IdentityTypeEnum {
        ACI = <any> 'ACI',
        PNI = <any> 'PNI'
    }
}
/**
 * 
 * @export
 * @interface CombinedUnidentifiedSenderAccessKeys
 */
export interface CombinedUnidentifiedSenderAccessKeys {
    /**
     * 
     * @type {string}
     * @memberof CombinedUnidentifiedSenderAccessKeys
     */
    accessKeys?: string;
}
/**
 * 
 * @export
 * @interface ConfirmPayPalBoostRequest
 */
export interface ConfirmPayPalBoostRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfirmPayPalBoostRequest
     */
    currency: string;
    /**
     * The amount to pay in the [currency's minor unit](https://docs.stripe.com/currencies#minor-units)
     * @type {number}
     * @memberof ConfirmPayPalBoostRequest
     */
    amount: number;
    /**
     * The level for the boost payment. Assumed to be the boost level if missing
     * @type {number}
     * @memberof ConfirmPayPalBoostRequest
     */
    level?: number;
    /**
     * The payment method
     * @type {string}
     * @memberof ConfirmPayPalBoostRequest
     */
    paymentMethod?: ConfirmPayPalBoostRequest.PaymentMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof ConfirmPayPalBoostRequest
     */
    payerId: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmPayPalBoostRequest
     */
    paymentId: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmPayPalBoostRequest
     */
    paymentToken: string;
}

/**
 * @export
 * @namespace ConfirmPayPalBoostRequest
 */
export namespace ConfirmPayPalBoostRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        UNKNOWN = <any> 'UNKNOWN',
        CARD = <any> 'CARD',
        PAYPAL = <any> 'PAYPAL',
        SEPADEBIT = <any> 'SEPA_DEBIT',
        IDEAL = <any> 'IDEAL',
        GOOGLEPLAYBILLING = <any> 'GOOGLE_PLAY_BILLING',
        APPLEAPPSTORE = <any> 'APPLE_APP_STORE'
    }
}
/**
 * 
 * @export
 * @interface ConfirmUsernameHashRequest
 */
export interface ConfirmUsernameHashRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfirmUsernameHashRequest
     */
    usernameHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfirmUsernameHashRequest
     */
    zkProof: string;
    /**
     * The url-safe base64-encoded encrypted username to be stored for username links
     * @type {string}
     * @memberof ConfirmUsernameHashRequest
     */
    encryptedUsername?: string;
}
/**
 * 
 * @export
 * @interface CopyMediaBatchRequest
 */
export interface CopyMediaBatchRequest {
    /**
     * A list of media objects to copy from the attachments CDN to the backup CDN
     * @type {Array<CopyMediaRequest>}
     * @memberof CopyMediaBatchRequest
     */
    items: Array<CopyMediaRequest>;
}
/**
 * 
 * @export
 * @interface CopyMediaBatchResponse
 */
export interface CopyMediaBatchResponse {
    /**
     * Detailed outcome information for each copy request in the batch
     * @type {Array<Entry>}
     * @memberof CopyMediaBatchResponse
     */
    responses?: Array<Entry>;
}
/**
 * 
 * @export
 * @interface CopyMediaRequest
 */
export interface CopyMediaRequest {
    /**
     * 
     * @type {RemoteAttachment}
     * @memberof CopyMediaRequest
     */
    sourceAttachment: RemoteAttachment;
    /**
     * The length of the source attachment before the encryption applied by the copy operation
     * @type {number}
     * @memberof CopyMediaRequest
     */
    objectLength: number;
    /**
     * mediaId to copy on to the backup CDN, encoded in URL-safe padded base64
     * @type {string}
     * @memberof CopyMediaRequest
     */
    mediaId: string;
    /**
     * A 32-byte key for the MAC, encoded in standard padded base64
     * @type {string}
     * @memberof CopyMediaRequest
     */
    hmacKey: string;
    /**
     * A 32-byte encryption key for AES, encoded in standard padded base64
     * @type {string}
     * @memberof CopyMediaRequest
     */
    encryptionKey: string;
}
/**
 * 
 * @export
 * @interface CopyMediaResponse
 */
export interface CopyMediaResponse {
    /**
     * The backup cdn where this media object is stored
     * @type {number}
     * @memberof CopyMediaResponse
     */
    cdn: number;
}
/**
 * 
 * @export
 * @interface CreateBoostReceiptCredentialsRequest
 */
export interface CreateBoostReceiptCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBoostReceiptCredentialsRequest
     */
    paymentIntentId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBoostReceiptCredentialsRequest
     */
    receiptCredentialRequest: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBoostReceiptCredentialsRequest
     */
    processor: CreateBoostReceiptCredentialsRequest.ProcessorEnum;
}

/**
 * @export
 * @namespace CreateBoostReceiptCredentialsRequest
 */
export namespace CreateBoostReceiptCredentialsRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ProcessorEnum {
        STRIPE = <any> 'STRIPE',
        BRAINTREE = <any> 'BRAINTREE',
        GOOGLEPLAYBILLING = <any> 'GOOGLE_PLAY_BILLING',
        APPLEAPPSTORE = <any> 'APPLE_APP_STORE'
    }
}
/**
 * 
 * @export
 * @interface CreateBoostRequest
 */
export interface CreateBoostRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBoostRequest
     */
    currency: string;
    /**
     * The amount to pay in the [currency's minor unit](https://docs.stripe.com/currencies#minor-units)
     * @type {number}
     * @memberof CreateBoostRequest
     */
    amount: number;
    /**
     * The level for the boost payment. Assumed to be the boost level if missing
     * @type {number}
     * @memberof CreateBoostRequest
     */
    level?: number;
    /**
     * The payment method
     * @type {string}
     * @memberof CreateBoostRequest
     */
    paymentMethod?: CreateBoostRequest.PaymentMethodEnum;
}

/**
 * @export
 * @namespace CreateBoostRequest
 */
export namespace CreateBoostRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        UNKNOWN = <any> 'UNKNOWN',
        CARD = <any> 'CARD',
        PAYPAL = <any> 'PAYPAL',
        SEPADEBIT = <any> 'SEPA_DEBIT',
        IDEAL = <any> 'IDEAL',
        GOOGLEPLAYBILLING = <any> 'GOOGLE_PLAY_BILLING',
        APPLEAPPSTORE = <any> 'APPLE_APP_STORE'
    }
}
/**
 * 
 * @export
 * @interface CreateBoostResponse
 */
export interface CreateBoostResponse {
    /**
     * A client secret that can be used to complete a stripe PaymentIntent
     * @type {string}
     * @memberof CreateBoostResponse
     */
    clientSecret?: string;
}
/**
 * 
 * @export
 * @interface CreateCallLinkCredential
 */
export interface CreateCallLinkCredential {
    /**
     * 
     * @type {string}
     * @memberof CreateCallLinkCredential
     */
    credential?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCallLinkCredential
     */
    redemptionTime?: number;
}
/**
 * 
 * @export
 * @interface CreatePayPalBillingAgreementRequest
 */
export interface CreatePayPalBillingAgreementRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePayPalBillingAgreementRequest
     */
    returnUrl: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePayPalBillingAgreementRequest
     */
    cancelUrl: string;
}
/**
 * 
 * @export
 * @interface CreatePayPalBoostRequest
 */
export interface CreatePayPalBoostRequest {
    /**
     * 
     * @type {string}
     * @memberof CreatePayPalBoostRequest
     */
    currency: string;
    /**
     * The amount to pay in the [currency's minor unit](https://docs.stripe.com/currencies#minor-units)
     * @type {number}
     * @memberof CreatePayPalBoostRequest
     */
    amount: number;
    /**
     * The level for the boost payment. Assumed to be the boost level if missing
     * @type {number}
     * @memberof CreatePayPalBoostRequest
     */
    level?: number;
    /**
     * The payment method
     * @type {string}
     * @memberof CreatePayPalBoostRequest
     */
    paymentMethod?: CreatePayPalBoostRequest.PaymentMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof CreatePayPalBoostRequest
     */
    returnUrl: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePayPalBoostRequest
     */
    cancelUrl: string;
}

/**
 * @export
 * @namespace CreatePayPalBoostRequest
 */
export namespace CreatePayPalBoostRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        UNKNOWN = <any> 'UNKNOWN',
        CARD = <any> 'CARD',
        PAYPAL = <any> 'PAYPAL',
        SEPADEBIT = <any> 'SEPA_DEBIT',
        IDEAL = <any> 'IDEAL',
        GOOGLEPLAYBILLING = <any> 'GOOGLE_PLAY_BILLING',
        APPLEAPPSTORE = <any> 'APPLE_APP_STORE'
    }
}
/**
 * 
 * @export
 * @interface CreateProfileRequest
 */
export interface CreateProfileRequest {
    /**
     * 
     * @type {ProfileKeyCommitment}
     * @memberof CreateProfileRequest
     */
    commitment: ProfileKeyCommitment;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    aboutEmoji?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    about?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    paymentAddress?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateProfileRequest
     */
    sameAvatar?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    phoneNumberSharing?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateProfileRequest
     */
    avatarChange?: CreateProfileRequest.AvatarChangeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CreateProfileRequest
     */
    avatar?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateProfileRequest
     */
    badgeIds?: Array<string>;
}

/**
 * @export
 * @namespace CreateProfileRequest
 */
export namespace CreateProfileRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum AvatarChangeEnum {
        UNCHANGED = <any> 'UNCHANGED',
        CLEAR = <any> 'CLEAR',
        UPDATE = <any> 'UPDATE'
    }
}
/**
 * 
 * @export
 * @interface CreateVerificationSessionRequest
 */
export interface CreateVerificationSessionRequest {
    /**
     * The e164-formatted phone number to be verified
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    number: string;
    /**
     * The APNs or FCM device token to which a push challenge can be sent
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    pushToken?: string;
    /**
     * The type of push token
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    pushTokenType?: CreateVerificationSessionRequest.PushTokenTypeEnum;
    /**
     * Value received by the device in the push challenge
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    pushChallenge?: string;
    /**
     * Captcha token returned after solving a captcha challenge
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    captcha?: string;
    /**
     * Mobile country code of the phone subscriber
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    mcc?: string;
    /**
     * Mobile network code of the phone subscriber
     * @type {string}
     * @memberof CreateVerificationSessionRequest
     */
    mnc?: string;
}

/**
 * @export
 * @namespace CreateVerificationSessionRequest
 */
export namespace CreateVerificationSessionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum PushTokenTypeEnum {
        Apn = <any> 'apn',
        Fcm = <any> 'fcm'
    }
}
/**
 * 
 * @export
 * @interface CredentialProfileResponse
 */
export interface CredentialProfileResponse {
    /**
     * 
     * @type {IdentityKey}
     * @memberof CredentialProfileResponse
     */
    identityKey?: IdentityKey;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    unidentifiedAccess?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CredentialProfileResponse
     */
    unrestrictedUnidentifiedAccess?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof CredentialProfileResponse
     */
    capabilities?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<Badge>}
     * @memberof CredentialProfileResponse
     */
    badges?: Array<Badge>;
    /**
     * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    about?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    aboutEmoji?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    paymentAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof CredentialProfileResponse
     */
    phoneNumberSharing?: string;
}
/**
 * Configuration for a currency - use to present appropriate client interfaces
 * @export
 * @interface CurrencyConfiguration
 */
export interface CurrencyConfiguration {
    /**
     * The minimum amount that may be submitted for a one-time donation in the currency
     * @type {number}
     * @memberof CurrencyConfiguration
     */
    minimum?: number;
    /**
     * A map of numeric one-time donation level IDs to the list of default amounts to be presented
     * @type {{ [key: string]: Array<number>; }}
     * @memberof CurrencyConfiguration
     */
    oneTime?: { [key: string]: Array<number>; };
    /**
     * A map of numeric subscription level IDs to the amount charged for that level
     * @type {{ [key: string]: number; }}
     * @memberof CurrencyConfiguration
     */
    subscription?: { [key: string]: number; };
    /**
     * A map of numeric backup level IDs to the amount charged for that level
     * @type {{ [key: string]: number; }}
     * @memberof CurrencyConfiguration
     */
    backupSubscription?: { [key: string]: number; };
    /**
     * The payment methods that support the given currency
     * @type {Array<string>}
     * @memberof CurrencyConfiguration
     */
    supportedPaymentMethods?: Array<string>;
}
/**
 * 
 * @export
 * @interface CurrencyConversionEntity
 */
export interface CurrencyConversionEntity {
    /**
     * 
     * @type {string}
     * @memberof CurrencyConversionEntity
     */
    base?: string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof CurrencyConversionEntity
     */
    conversions?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface CurrencyConversionEntityList
 */
export interface CurrencyConversionEntityList {
    /**
     * 
     * @type {Array<CurrencyConversionEntity>}
     * @memberof CurrencyConversionEntityList
     */
    currencies?: Array<CurrencyConversionEntity>;
    /**
     * 
     * @type {number}
     * @memberof CurrencyConversionEntityList
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @interface DeleteMedia
 */
export interface DeleteMedia {
    /**
     * 
     * @type {Array<MediaToDelete>}
     * @memberof DeleteMedia
     */
    mediaToDelete?: Array<MediaToDelete>;
}
/**
 * 
 * @export
 * @interface DeliveryCertificate
 */
export interface DeliveryCertificate {
    /**
     * 
     * @type {string}
     * @memberof DeliveryCertificate
     */
    certificate?: string;
}
/**
 * 
 * @export
 * @interface DeviceActivationRequest
 */
export interface DeviceActivationRequest {
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof DeviceActivationRequest
     */
    aciSignedPreKey: ECSignedPreKey;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof DeviceActivationRequest
     */
    pniSignedPreKey: ECSignedPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof DeviceActivationRequest
     */
    aciPqLastResortPreKey: KEMSignedPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof DeviceActivationRequest
     */
    pniPqLastResortPreKey: KEMSignedPreKey;
    /**
     * 
     * @type {ApnRegistrationId}
     * @memberof DeviceActivationRequest
     */
    apnToken?: ApnRegistrationId;
    /**
     * 
     * @type {GcmRegistrationId}
     * @memberof DeviceActivationRequest
     */
    gcmToken?: GcmRegistrationId;
}
/**
 * 
 * @export
 * @interface DeviceDataReport
 */
export interface DeviceDataReport {
    /**
     * 
     * @type {string}
     * @memberof DeviceDataReport
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof DeviceDataReport
     */
    lastSeen?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DeviceDataReport
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof DeviceDataReport
     */
    userAgent?: string;
}
/**
 * 
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * 
     * @type {number}
     * @memberof DeviceInfo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceInfo
     */
    lastSeen?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceInfo
     */
    created?: number;
}
/**
 * 
 * @export
 * @interface DeviceInfoList
 */
export interface DeviceInfoList {
    /**
     * 
     * @type {Array<DeviceInfo>}
     * @memberof DeviceInfoList
     */
    devices?: Array<DeviceInfo>;
}
/**
 * 
 * @export
 * @interface DeviceName
 */
export interface DeviceName {
    /**
     * 
     * @type {string}
     * @memberof DeviceName
     */
    deviceName: string;
}
/**
 * 
 * @export
 * @interface E164Monitor
 */
export interface E164Monitor {
    /**
     * The e164-formatted phone number to monitor
     * @type {string}
     * @memberof E164Monitor
     */
    value: string;
    /**
     * A log tree position maintained by the client for the e164.
     * @type {number}
     * @memberof E164Monitor
     */
    entryPosition?: number;
    /**
     * The commitment index derived from a previous search request, encoded in standard unpadded base64
     * @type {string}
     * @memberof E164Monitor
     */
    commitmentIndex: string;
}
/**
 * A list of unsigned elliptic-curve prekeys to use for this device. If present and not empty, replaces all stored unsigned EC prekeys for the device; if absent or empty, any stored unsigned EC prekeys for the device are not deleted. 
 * @export
 * @interface ECPreKey
 */
export interface ECPreKey {
    /**
     * An arbitrary ID for this key, which will be provided by peers using this key to encrypt messages so the private key can be looked up. Should not be zero. Should be less than 2^24. 
     * @type {number}
     * @memberof ECPreKey
     */
    keyId?: number;
    /**
     * The public key, serialized in libsignal's elliptic-curve public key format and then base64-encoded. 
     * @type {string}
     * @memberof ECPreKey
     */
    publicKey?: string;
}
/**
 * 
 * @export
 * @interface ECPublicKey
 */
export interface ECPublicKey {
    /**
     * 
     * @type {string}
     * @memberof ECPublicKey
     */
    publicKeyBytes?: string;
    /**
     * 
     * @type {number}
     * @memberof ECPublicKey
     */
    type?: number;
}
/**
 * A signed EC pre-key to be associated with this account's PNI. 
 * @export
 * @interface ECSignedPreKey
 */
export interface ECSignedPreKey {
    /**
     * An arbitrary ID for this key, which will be provided by peers using this key to encrypt messages so the private key can be looked up. Should not be zero. Should be less than 2^24. 
     * @type {number}
     * @memberof ECSignedPreKey
     */
    keyId?: number;
    /**
     * The public key, serialized in libsignal's elliptic-curve public key format and then base64-encoded. 
     * @type {string}
     * @memberof ECSignedPreKey
     */
    publicKey?: string;
    /**
     * The signature of the serialized `publicKey` with the account (or phone-number identity)'s identity key, base64-encoded. 
     * @type {string}
     * @memberof ECSignedPreKey
     */
    signature?: string;
}
/**
 * 
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
     * @type {string}
     * @memberof Element
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof Element
     */
    fingerprint: string;
}
/**
 * 
 * @export
 * @interface EncryptedUsername
 */
export interface EncryptedUsername {
    /**
     * the URL-safe base64 encoding of the encrypted username
     * @type {string}
     * @memberof EncryptedUsername
     */
    usernameLinkEncryptedValue: string;
    /**
     * if set and the account already has an encrypted-username link handle, reuse the same link handle rather than generating a new one. The response will still have the link handle.
     * @type {boolean}
     * @memberof EncryptedUsername
     */
    keepLinkHandle?: boolean;
}
/**
 * entitlements for this account and their current expirations
 * @export
 * @interface Entitlements
 */
export interface Entitlements {
    /**
     * Active badges added via /v1/donation/redeem-receipt
     * @type {Array<BadgeEntitlement>}
     * @memberof Entitlements
     */
    badges?: Array<BadgeEntitlement>;
    /**
     * 
     * @type {BackupEntitlement}
     * @memberof Entitlements
     */
    backup?: BackupEntitlement;
}
/**
 * Detailed outcome information for each copy request in the batch
 * @export
 * @interface Entry
 */
export interface Entry {
    /**
     * The outcome of the copy attempt. A 200 indicates the object was successfully copied. A 400 indicates an invalid argument in the request A 410 indicates that the source object was not found A 413 indicates that the media quota was exhausted 
     * @type {number}
     * @memberof Entry
     */
    status?: number;
    /**
     * On a copy failure, a detailed failure reason
     * @type {string}
     * @memberof Entry
     */
    failureReason?: string;
    /**
     * The backup cdn where this media object is stored
     * @type {number}
     * @memberof Entry
     */
    cdn?: number;
    /**
     * The mediaId of the object, encoded in URL-safe padded base64
     * @type {string}
     * @memberof Entry
     */
    mediaId: string;
}
/**
 * 
 * @export
 * @interface ExternalServiceCredentials
 */
export interface ExternalServiceCredentials {
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceCredentials
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalServiceCredentials
     */
    password?: string;
}
/**
 * An FCM/GCM token for the account's primary device. If provided, the account's primary device will be notified of new messages via push notifications to the given token. Callers must provide exactly one of an APNs token set, an FCM token, or an `AccountAttributes` entity with `fetchesMessages` set to `true`. 
 * @export
 * @interface GcmRegistrationId
 */
export interface GcmRegistrationId {
    /**
     * 
     * @type {string}
     * @memberof GcmRegistrationId
     */
    gcmRegistrationId: string;
}
/**
 * 
 * @export
 * @interface GetCallingRelaysResponse
 */
export interface GetCallingRelaysResponse {
    /**
     * 
     * @type {Array<TurnToken>}
     * @memberof GetCallingRelaysResponse
     */
    relays?: Array<TurnToken>;
}
/**
 * 
 * @export
 * @interface GetCreateCallLinkCredentialsRequest
 */
export interface GetCreateCallLinkCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetCreateCallLinkCredentialsRequest
     */
    createCallLinkCredentialRequest: string;
}
/**
 * 
 * @export
 * @interface GetReceiptCredentialsRequest
 */
export interface GetReceiptCredentialsRequest {
    /**
     * 
     * @type {string}
     * @memberof GetReceiptCredentialsRequest
     */
    receiptCredentialRequest: string;
}
/**
 * Comprehensive configuration for donation subscriptions, backup subscriptions, gift subscriptions, and one-time donations pricing information for all levels are included in currencies. All levels that have an associated badge are included in levels.  All levels that correspond to a backup payment tier are included in backupLevels.
 * @export
 * @interface GetSubscriptionConfigurationResponse
 */
export interface GetSubscriptionConfigurationResponse {
    /**
     * A map of lower-cased ISO 3 currency codes to minimums and level-specific scalar amounts
     * @type {{ [key: string]: CurrencyConfiguration; }}
     * @memberof GetSubscriptionConfigurationResponse
     */
    currencies?: { [key: string]: CurrencyConfiguration; };
    /**
     * A map of numeric donation level IDs to level-specific badge configuration
     * @type {{ [key: string]: LevelConfiguration; }}
     * @memberof GetSubscriptionConfigurationResponse
     */
    levels?: { [key: string]: LevelConfiguration; };
    /**
     * 
     * @type {BackupConfiguration}
     * @memberof GetSubscriptionConfigurationResponse
     */
    backup?: BackupConfiguration;
    /**
     * The maximum value of a one-time donation SEPA transaction
     * @type {number}
     * @memberof GetSubscriptionConfigurationResponse
     */
    sepaMaximumEuros?: number;
}
/**
 * 
 * @export
 * @interface GetSubscriptionInformationResponse
 */
export interface GetSubscriptionInformationResponse {
    /**
     * 
     * @type {Subscription}
     * @memberof GetSubscriptionInformationResponse
     */
    subscription?: Subscription;
    /**
     * 
     * @type {ChargeFailure}
     * @memberof GetSubscriptionInformationResponse
     */
    chargeFailure?: ChargeFailure;
}
/**
 * 
 * @export
 * @interface GroupCredential
 */
export interface GroupCredential {
    /**
     * 
     * @type {string}
     * @memberof GroupCredential
     */
    credential?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupCredential
     */
    redemptionTime?: number;
}
/**
 * 
 * @export
 * @interface GroupCredentials
 */
export interface GroupCredentials {
    /**
     * 
     * @type {Array<GroupCredential>}
     * @memberof GroupCredentials
     */
    credentials?: Array<GroupCredential>;
    /**
     * 
     * @type {Array<CallLinkAuthCredential>}
     * @memberof GroupCredentials
     */
    callLinkAuthCredentials?: Array<CallLinkAuthCredential>;
    /**
     * 
     * @type {string}
     * @memberof GroupCredentials
     */
    pni?: string;
}
/**
 * 
 * @export
 * @interface GroupSendFullToken
 */
export interface GroupSendFullToken {
    /**
     * 
     * @type {Date}
     * @memberof GroupSendFullToken
     */
    expiration?: Date;
    /**
     * 
     * @type {string}
     * @memberof GroupSendFullToken
     */
    internalContentsForJNI?: string;
}
/**
 * 
 * @export
 * @interface GroupSendTokenHeader
 */
export interface GroupSendTokenHeader {
    /**
     * 
     * @type {GroupSendFullToken}
     * @memberof GroupSendTokenHeader
     */
    token?: GroupSendFullToken;
}
/**
 * The PNI-associated identity key for the account, encoded as a base64 string. 
 * @export
 * @interface IdentityKey
 */
export interface IdentityKey {
    /**
     * 
     * @type {ECPublicKey}
     * @memberof IdentityKey
     */
    publicKey?: ECPublicKey;
    /**
     * 
     * @type {string}
     * @memberof IdentityKey
     */
    fingerprint?: string;
}
/**
 * 
 * @export
 * @interface IncomingMessage
 */
export interface IncomingMessage {
    /**
     * 
     * @type {number}
     * @memberof IncomingMessage
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof IncomingMessage
     */
    destinationDeviceId?: string;
    /**
     * 
     * @type {number}
     * @memberof IncomingMessage
     */
    destinationRegistrationId?: number;
    /**
     * 
     * @type {string}
     * @memberof IncomingMessage
     */
    content?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IncomingMessage
     */
    validEnvelopeType?: boolean;
}
/**
 * 
 * @export
 * @interface IncomingMessageList
 */
export interface IncomingMessageList {
    /**
     * 
     * @type {Array<IncomingMessage>}
     * @memberof IncomingMessageList
     */
    messages: Array<IncomingMessage>;
    /**
     * 
     * @type {boolean}
     * @memberof IncomingMessageList
     */
    online?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IncomingMessageList
     */
    urgent?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IncomingMessageList
     */
    timestamp?: number;
}
/**
 * The location of the transfer archive if the archive was successfully uploaded, otherwise a error indicating that  the upload has failed and the destination device should stop waiting 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponseDefault
     */
    completedExceptionally?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    numberOfDependents?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponseDefault
     */
    done?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponseDefault
     */
    cancelled?: boolean;
}
/**
 * A signed Kyber-1024 \"last resort\" pre-key to be associated with this account's PNI. 
 * @export
 * @interface KEMSignedPreKey
 */
export interface KEMSignedPreKey {
    /**
     * An arbitrary ID for this key, which will be provided by peers using this key to encrypt messages so the private key can be looked up. Should not be zero. Should be less than 2^24. The owner of this key must be able to determine from the key ID whether this represents a single-use or last-resort key, but another party should *not* be able to tell. 
     * @type {number}
     * @memberof KEMSignedPreKey
     */
    keyId?: number;
    /**
     * The public key, serialized in libsignal's Kyber1024 public key format and then base64-encoded. 
     * @type {string}
     * @memberof KEMSignedPreKey
     */
    publicKey?: string;
    /**
     * The signature of the serialized `publicKey` with the account (or phone-number identity)'s identity key, base64-encoded. 
     * @type {string}
     * @memberof KEMSignedPreKey
     */
    signature?: string;
}
/**
 * 
 * @export
 * @interface KeyTransparencyDistinguishedKeyResponse
 */
export interface KeyTransparencyDistinguishedKeyResponse {
    /**
     * The serialized `DistinguishedResponse` encoded in standard un-padded base64
     * @type {string}
     * @memberof KeyTransparencyDistinguishedKeyResponse
     */
    serializedResponse: string;
}
/**
 * 
 * @export
 * @interface KeyTransparencyMonitorRequest
 */
export interface KeyTransparencyMonitorRequest {
    /**
     * 
     * @type {AciMonitor}
     * @memberof KeyTransparencyMonitorRequest
     */
    aci: AciMonitor;
    /**
     * 
     * @type {E164Monitor}
     * @memberof KeyTransparencyMonitorRequest
     */
    e164: E164Monitor;
    /**
     * 
     * @type {UsernameHashMonitor}
     * @memberof KeyTransparencyMonitorRequest
     */
    usernameHash: UsernameHashMonitor;
    /**
     * The tree head size to prove consistency against.
     * @type {number}
     * @memberof KeyTransparencyMonitorRequest
     */
    lastNonDistinguishedTreeHeadSize?: number;
    /**
     * The distinguished tree head size to prove consistency against.
     * @type {number}
     * @memberof KeyTransparencyMonitorRequest
     */
    lastDistinguishedTreeHeadSize?: number;
}
/**
 * 
 * @export
 * @interface KeyTransparencyMonitorResponse
 */
export interface KeyTransparencyMonitorResponse {
    /**
     * The serialized `MonitorResponse` encoded in standard un-padded base64
     * @type {string}
     * @memberof KeyTransparencyMonitorResponse
     */
    serializedResponse: string;
}
/**
 * 
 * @export
 * @interface KeyTransparencySearchRequest
 */
export interface KeyTransparencySearchRequest {
    /**
     * An identifier for an account based on the account's ACI
     * @type {string}
     * @memberof KeyTransparencySearchRequest
     */
    aci: string;
    /**
     * The E164-formatted phone number to look up
     * @type {string}
     * @memberof KeyTransparencySearchRequest
     */
    e164?: string;
    /**
     * The username hash to look up, encoded in web-safe unpadded base64.
     * @type {string}
     * @memberof KeyTransparencySearchRequest
     */
    usernameHash?: string;
    /**
     * 
     * @type {IdentityKey}
     * @memberof KeyTransparencySearchRequest
     */
    aciIdentityKey: IdentityKey;
    /**
     * The unidentified access key associated with the account
     * @type {string}
     * @memberof KeyTransparencySearchRequest
     */
    unidentifiedAccessKey?: string;
    /**
     * The non-distinguished tree head size to prove consistency against.
     * @type {number}
     * @memberof KeyTransparencySearchRequest
     */
    lastTreeHeadSize?: number;
    /**
     * The distinguished tree head size to prove consistency against.
     * @type {number}
     * @memberof KeyTransparencySearchRequest
     */
    distinguishedTreeHeadSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof KeyTransparencySearchRequest
     */
    unidentifiedAccessKeyProvidedWithE164?: boolean;
}
/**
 * 
 * @export
 * @interface KeyTransparencySearchResponse
 */
export interface KeyTransparencySearchResponse {
    /**
     * The serialized `SearchResponse` encoded in standard un-padded base64.
     * @type {string}
     * @memberof KeyTransparencySearchResponse
     */
    serializedResponse: string;
}
/**
 * Configuration for a donation level - use to present appropriate client interfaces
 * @export
 * @interface LevelConfiguration
 */
export interface LevelConfiguration {
    /**
     * The localized name for the level
     * @type {string}
     * @memberof LevelConfiguration
     */
    name?: string;
    /**
     * 
     * @type {Badge}
     * @memberof LevelConfiguration
     */
    badge?: Badge;
}
/**
 * 
 * @export
 * @interface LinkDeviceRequest
 */
export interface LinkDeviceRequest {
    /**
     * The verification code associated with this device. Must match the verification code provided by the server when provisioning this device. 
     * @type {string}
     * @memberof LinkDeviceRequest
     */
    verificationCode: string;
    /**
     * 
     * @type {AccountAttributes}
     * @memberof LinkDeviceRequest
     */
    accountAttributes?: AccountAttributes;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof LinkDeviceRequest
     */
    aciSignedPreKey: ECSignedPreKey;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof LinkDeviceRequest
     */
    pniSignedPreKey: ECSignedPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof LinkDeviceRequest
     */
    aciPqLastResortPreKey: KEMSignedPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof LinkDeviceRequest
     */
    pniPqLastResortPreKey: KEMSignedPreKey;
    /**
     * 
     * @type {ApnRegistrationId}
     * @memberof LinkDeviceRequest
     */
    apnToken?: ApnRegistrationId;
    /**
     * 
     * @type {GcmRegistrationId}
     * @memberof LinkDeviceRequest
     */
    gcmToken?: GcmRegistrationId;
}
/**
 * 
 * @export
 * @interface LinkDeviceResponse
 */
export interface LinkDeviceResponse {
    /**
     * 
     * @type {string}
     * @memberof LinkDeviceResponse
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkDeviceResponse
     */
    pni?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkDeviceResponse
     */
    deviceId?: string;
}
/**
 * 
 * @export
 * @interface LinkDeviceToken
 */
export interface LinkDeviceToken {
    /**
     * An opaque identifier for the generated token that the caller may use to watch for a new device to complete the linking process. 
     * @type {string}
     * @memberof LinkDeviceToken
     */
    tokenIdentifier?: string;
    /**
     * An opaque token to send to a new linked device that authorizes the new device to link itself to the account that requested this token. 
     * @type {string}
     * @memberof LinkDeviceToken
     */
    verificationCode?: string;
}
/**
 * 
 * @export
 * @interface ListResponse
 */
export interface ListResponse {
    /**
     * A page of media objects stored for this backup ID
     * @type {Array<StoredMediaObject>}
     * @memberof ListResponse
     */
    storedMediaObjects?: Array<StoredMediaObject>;
    /**
     * The base directory of your backup data on the cdn. The stored media can be found at /backupDir/mediaDir/mediaId 
     * @type {string}
     * @memberof ListResponse
     */
    backupDir?: string;
    /**
     * The prefix path component for the media objects. The stored media for mediaId can be found at /backupDir/mediaDir/mediaId. 
     * @type {string}
     * @memberof ListResponse
     */
    mediaDir?: string;
    /**
     * If set, the cursor value to pass to the next list request to continue listing. If absent, all objects have been listed
     * @type {string}
     * @memberof ListResponse
     */
    cursor?: string;
}
/**
 * 
 * @export
 * @interface MediaToDelete
 */
export interface MediaToDelete {
    /**
     * The backup cdn where this media object is stored
     * @type {number}
     * @memberof MediaToDelete
     */
    cdn: number;
    /**
     * The mediaId of the object in URL-safe base64
     * @type {string}
     * @memberof MediaToDelete
     */
    mediaId: string;
}
/**
 * 
 * @export
 * @interface MismatchedDevices
 */
export interface MismatchedDevices {
    /**
     * Devices present on the account but absent in the request
     * @type {Array<string>}
     * @memberof MismatchedDevices
     */
    missingDevices?: Array<string>;
    /**
     * Devices absent on the request but present in the account
     * @type {Array<string>}
     * @memberof MismatchedDevices
     */
    extraDevices?: Array<string>;
}
/**
 * 
 * @export
 * @interface PhoneNumberDiscoverabilityRequest
 */
export interface PhoneNumberDiscoverabilityRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PhoneNumberDiscoverabilityRequest
     */
    discoverableByPhoneNumber: boolean;
}
/**
 * 
 * @export
 * @interface PhoneNumberIdentityKeyDistributionRequest
 */
export interface PhoneNumberIdentityKeyDistributionRequest {
    /**
     * 
     * @type {IdentityKey}
     * @memberof PhoneNumberIdentityKeyDistributionRequest
     */
    pniIdentityKey: IdentityKey;
    /**
     * A list of synchronization messages to send to companion devices to supply the private keys associated with the new identity key and their new prekeys. Exactly one message must be supplied for each enabled device other than the sending (primary) device. 
     * @type {Array<IncomingMessage>}
     * @memberof PhoneNumberIdentityKeyDistributionRequest
     */
    deviceMessages: Array<IncomingMessage>;
    /**
     * A new signed elliptic-curve prekey for each enabled device on the account, including this one. Each must be accompanied by a valid signature from the new identity key in this request.
     * @type {{ [key: string]: ECSignedPreKey; }}
     * @memberof PhoneNumberIdentityKeyDistributionRequest
     */
    devicePniSignedPrekeys: { [key: string]: ECSignedPreKey; };
    /**
     * A new signed post-quantum last-resort prekey for each enabled device on the account, including this one. May be absent, in which case the last resort PQ prekeys for each device will be deleted if any had been stored. If present, must contain one prekey per enabled device including this one. Prekeys for devices that did not previously have any post-quantum prekeys stored will be silently dropped. Each must be accompanied by a valid signature from the new identity key in this request.
     * @type {{ [key: string]: KEMSignedPreKey; }}
     * @memberof PhoneNumberIdentityKeyDistributionRequest
     */
    devicePniPqLastResortPrekeys?: { [key: string]: KEMSignedPreKey; };
    /**
     * The new registration ID to use for the phone-number identity of each device, including this one.
     * @type {{ [key: string]: number; }}
     * @memberof PhoneNumberIdentityKeyDistributionRequest
     */
    pniRegistrationIds: { [key: string]: number; };
}
/**
 * An identifier for an account based on the account's phone number identifier (PNI)
 * @export
 * @interface PniServiceIdentifier
 */
export interface PniServiceIdentifier extends ServiceIdentifier {
}
/**
 * 
 * @export
 * @interface PreKeyCount
 */
export interface PreKeyCount {
    /**
     * the number of stored unsigned elliptic-curve prekeys for this device
     * @type {number}
     * @memberof PreKeyCount
     */
    count?: number;
    /**
     * the number of stored one-time post-quantum prekeys for this device
     * @type {number}
     * @memberof PreKeyCount
     */
    pqCount?: number;
}
/**
 * 
 * @export
 * @interface PreKeyResponse
 */
export interface PreKeyResponse {
    /**
     * 
     * @type {IdentityKey}
     * @memberof PreKeyResponse
     */
    identityKey?: IdentityKey;
    /**
     * information about each requested device
     * @type {Array<PreKeyResponseItem>}
     * @memberof PreKeyResponse
     */
    devices?: Array<PreKeyResponseItem>;
}
/**
 * information about each requested device
 * @export
 * @interface PreKeyResponseItem
 */
export interface PreKeyResponseItem {
    /**
     * the device ID of the device to which this item pertains
     * @type {string}
     * @memberof PreKeyResponseItem
     */
    deviceId?: string;
    /**
     * the registration ID for the device
     * @type {number}
     * @memberof PreKeyResponseItem
     */
    registrationId?: number;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof PreKeyResponseItem
     */
    signedPreKey?: ECSignedPreKey;
    /**
     * 
     * @type {ECPreKey}
     * @memberof PreKeyResponseItem
     */
    preKey?: ECPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof PreKeyResponseItem
     */
    pqPreKey?: KEMSignedPreKey;
}
/**
 * 
 * @export
 * @interface ProfileKeyCommitment
 */
export interface ProfileKeyCommitment {
    /**
     * 
     * @type {string}
     * @memberof ProfileKeyCommitment
     */
    internalContentsForJNI?: string;
}
/**
 * 
 * @export
 * @interface ProvisioningMessage
 */
export interface ProvisioningMessage {
    /**
     * The MIME base64-encoded body of the provisioning message to send to the destination device
     * @type {string}
     * @memberof ProvisioningMessage
     */
    body: string;
}
/**
 * 
 * @export
 * @interface ReadAuthResponse
 */
export interface ReadAuthResponse {
    /**
     * Auth headers to include with cdn read requests
     * @type {{ [key: string]: string; }}
     * @memberof ReadAuthResponse
     */
    headers?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Recipient
 */
export interface Recipient {
    /**
     * 
     * @type {string}
     * @memberof Recipient
     */
    devices?: string;
    /**
     * 
     * @type {RecipientDevicesAndRegistrationIds}
     * @memberof Recipient
     */
    devicesAndRegistrationIds?: RecipientDevicesAndRegistrationIds;
}
/**
 * 
 * @export
 * @interface RecipientDevicesAndRegistrationIds
 */
export interface RecipientDevicesAndRegistrationIds {
    /**
     * 
     * @type {boolean}
     * @memberof RecipientDevicesAndRegistrationIds
     */
    parallel?: boolean;
}
/**
 * 
 * @export
 * @interface RedeemBackupReceiptRequest
 */
export interface RedeemBackupReceiptRequest {
    /**
     * Presentation of a ZK receipt encoded in standard padded base64
     * @type {string}
     * @memberof RedeemBackupReceiptRequest
     */
    receiptCredentialPresentation: string;
}
/**
 * 
 * @export
 * @interface RedeemReceiptRequest
 */
export interface RedeemReceiptRequest {
    /**
     * 
     * @type {string}
     * @memberof RedeemReceiptRequest
     */
    receiptCredentialPresentation: string;
    /**
     * 
     * @type {boolean}
     * @memberof RedeemReceiptRequest
     */
    visible?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedeemReceiptRequest
     */
    primary?: boolean;
}
/**
 * 
 * @export
 * @interface RegistrationLock
 */
export interface RegistrationLock {
    /**
     * 
     * @type {string}
     * @memberof RegistrationLock
     */
    registrationLock: string;
}
/**
 * Information about the current Registration lock and SVR credentials. With a correct PIN, the credentials can be used to recover the secret used to derive the registration lock password. 
 * @export
 * @interface RegistrationLockFailure
 */
export interface RegistrationLockFailure {
    /**
     * Time remaining in milliseconds before the existing registration lock expires
     * @type {number}
     * @memberof RegistrationLockFailure
     */
    timeRemaining?: number;
    /**
     * 
     * @type {ExternalServiceCredentials}
     * @memberof RegistrationLockFailure
     */
    svr2Credentials?: ExternalServiceCredentials;
}
/**
 * 
 * @export
 * @interface RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * The ID of an existing verification session as it appears in a verification session metadata object. Must be provided if `recoveryPassword` is not provided; must not be provided if `recoveryPassword` is provided. 
     * @type {string}
     * @memberof RegistrationRequest
     */
    sessionId?: string;
    /**
     * A base64-encoded registration recovery password. Must be provided if `sessionId` is not provided; must not be provided if `sessionId` is provided 
     * @type {string}
     * @memberof RegistrationRequest
     */
    recoveryPassword?: string;
    /**
     * 
     * @type {AccountAttributes}
     * @memberof RegistrationRequest
     */
    accountAttributes: AccountAttributes;
    /**
     * If true, indicates that the end user has elected not to transfer data from another device even though a device transfer is technically possible given the capabilities of the calling device and the device associated with the existing account (if any). If false and if a device transfer is technically possible, the registration request will fail with an HTTP/409 response indicating that the client should prompt the user to transfer data from an existing device. 
     * @type {boolean}
     * @memberof RegistrationRequest
     */
    skipDeviceTransfer: boolean;
    /**
     * 
     * @type {IdentityKey}
     * @memberof RegistrationRequest
     */
    aciIdentityKey: IdentityKey;
    /**
     * 
     * @type {IdentityKey}
     * @memberof RegistrationRequest
     */
    pniIdentityKey: IdentityKey;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof RegistrationRequest
     */
    aciSignedPreKey: ECSignedPreKey;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof RegistrationRequest
     */
    pniSignedPreKey: ECSignedPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof RegistrationRequest
     */
    aciPqLastResortPreKey: KEMSignedPreKey;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof RegistrationRequest
     */
    pniPqLastResortPreKey: KEMSignedPreKey;
    /**
     * 
     * @type {ApnRegistrationId}
     * @memberof RegistrationRequest
     */
    apnToken?: ApnRegistrationId;
    /**
     * 
     * @type {GcmRegistrationId}
     * @memberof RegistrationRequest
     */
    gcmToken?: GcmRegistrationId;
    /**
     * 
     * @type {boolean}
     * @memberof RegistrationRequest
     */
    valid?: boolean;
}
/**
 * 
 * @export
 * @interface RemoteAttachment
 */
export interface RemoteAttachment {
    /**
     * The attachment cdn
     * @type {number}
     * @memberof RemoteAttachment
     */
    cdn: number;
    /**
     * The attachment key
     * @type {string}
     * @memberof RemoteAttachment
     */
    key: string;
}
/**
 * Indicates an attachment failed to upload
 * @export
 * @interface RemoteAttachmentError
 */
export interface RemoteAttachmentError {
    /**
     * The type of error encountered
     * @type {string}
     * @memberof RemoteAttachmentError
     */
    error: RemoteAttachmentError.ErrorEnum;
}

/**
 * @export
 * @namespace RemoteAttachmentError
 */
export namespace RemoteAttachmentError {
    /**
     * @export
     * @enum {string}
     */
    export enum ErrorEnum {
        RELINKREQUESTED = <any> 'RELINK_REQUESTED',
        CONTINUEWITHOUTUPLOAD = <any> 'CONTINUE_WITHOUT_UPLOAD'
    }
}
/**
 * 
 * @export
 * @interface ReserveUsernameHashRequest
 */
export interface ReserveUsernameHashRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReserveUsernameHashRequest
     */
    usernameHashes: Array<string>;
}
/**
 * 
 * @export
 * @interface ReserveUsernameHashResponse
 */
export interface ReserveUsernameHashResponse {
    /**
     * 
     * @type {string}
     * @memberof ReserveUsernameHashResponse
     */
    usernameHash?: string;
}
/**
 * Represents a request from a new device to restore account data by some method. 
 * @export
 * @interface RestoreAccountRequest
 */
export interface RestoreAccountRequest {
    /**
     * The method by which the new device has requested account data restoration
     * @type {string}
     * @memberof RestoreAccountRequest
     */
    method: RestoreAccountRequest.MethodEnum;
    /**
     * Additional data to use to bootstrap a connection between devices, in standard unpadded base64.
     * @type {string}
     * @memberof RestoreAccountRequest
     */
    deviceTransferBootstrap?: string;
}

/**
 * @export
 * @namespace RestoreAccountRequest
 */
export namespace RestoreAccountRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        REMOTEBACKUP = <any> 'REMOTE_BACKUP',
        LOCALBACKUP = <any> 'LOCAL_BACKUP',
        DEVICETRANSFER = <any> 'DEVICE_TRANSFER',
        DECLINE = <any> 'DECLINE'
    }
}
/**
 * 
 * @export
 * @interface SealedSenderMultiRecipientMessage
 */
export interface SealedSenderMultiRecipientMessage {
    /**
     * 
     * @type {{ [key: string]: Recipient; }}
     * @memberof SealedSenderMultiRecipientMessage
     */
    recipients?: { [key: string]: Recipient; };
    /**
     * 
     * @type {Array<ServiceId>}
     * @memberof SealedSenderMultiRecipientMessage
     */
    excludedRecipients?: Array<ServiceId>;
}
/**
 * 
 * @export
 * @interface SendMultiRecipientMessageResponse
 */
export interface SendMultiRecipientMessageResponse {
    /**
     * a list of the service identifiers in the request that do not correspond to registered Signal users; will only be present if a group send endorsement was supplied for the request
     * @type {Array<string>}
     * @memberof SendMultiRecipientMessageResponse
     */
    uuids404?: Array<string>;
}
/**
 * 
 * @export
 * @interface SendVerificationCodeFailureResponse
 */
export interface SendVerificationCodeFailureResponse {
    /**
     * 
     * @type {string}
     * @memberof SendVerificationCodeFailureResponse
     */
    reason?: SendVerificationCodeFailureResponse.ReasonEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SendVerificationCodeFailureResponse
     */
    permanentFailure?: boolean;
}

/**
 * @export
 * @namespace SendVerificationCodeFailureResponse
 */
export namespace SendVerificationCodeFailureResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonEnum {
        ProviderUnavailable = <any> 'providerUnavailable',
        ProviderRejected = <any> 'providerRejected',
        IllegalArgument = <any> 'illegalArgument'
    }
}
/**
 * 
 * @export
 * @interface ServiceId
 */
export interface ServiceId {
    /**
     * 
     * @type {string}
     * @memberof ServiceId
     */
    rawUUID?: string;
}
/**
 * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
 * @export
 * @interface ServiceIdentifier
 */
export interface ServiceIdentifier {
}
/**
 * 
 * @export
 * @interface SetBackupIdRequest
 */
export interface SetBackupIdRequest {
    /**
     * A BackupAuthCredentialRequest containing a blinded encrypted backup-id, encoded in standard padded base64. This backup-id should be used for message backups only, and must have the message backup type set on the credential. 
     * @type {string}
     * @memberof SetBackupIdRequest
     */
    messagesBackupAuthCredentialRequest: string;
    /**
     * A BackupAuthCredentialRequest containing a blinded encrypted backup-id, encoded in standard padded base64. This backup-id should be used for media only, and must have the media type set on the credential. 
     * @type {string}
     * @memberof SetBackupIdRequest
     */
    mediaBackupAuthCredentialRequest: string;
}
/**
 * 
 * @export
 * @interface SetKeysRequest
 */
export interface SetKeysRequest {
    /**
     * A list of unsigned elliptic-curve prekeys to use for this device. If present and not empty, replaces all stored unsigned EC prekeys for the device; if absent or empty, any stored unsigned EC prekeys for the device are not deleted. 
     * @type {Array<ECPreKey>}
     * @memberof SetKeysRequest
     */
    preKeys?: Array<ECPreKey>;
    /**
     * 
     * @type {ECSignedPreKey}
     * @memberof SetKeysRequest
     */
    signedPreKey?: ECSignedPreKey;
    /**
     * A list of signed post-quantum one-time prekeys to use for this device. Each key must have a valid signature from the identity key in this request. If present and not empty, replaces all stored unsigned PQ prekeys for the device; if absent or empty, any stored unsigned PQ prekeys for the device are not deleted. 
     * @type {Array<KEMSignedPreKey>}
     * @memberof SetKeysRequest
     */
    pqPreKeys?: Array<KEMSignedPreKey>;
    /**
     * 
     * @type {KEMSignedPreKey}
     * @memberof SetKeysRequest
     */
    pqLastResortPreKey?: KEMSignedPreKey;
}
/**
 * 
 * @export
 * @interface SetPublicKeyRequest
 */
export interface SetPublicKeyRequest {
    /**
     * The public key, serialized in libsignal's elliptic-curve public key format and then encoded as a standard (i.e. not URL-safe), padded, base64-encoded string. 
     * @type {string}
     * @memberof SetPublicKeyRequest
     */
    publicKey?: string;
}
/**
 * 
 * @export
 * @interface SpamReport
 */
export interface SpamReport {
    /**
     * 
     * @type {string}
     * @memberof SpamReport
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface StaleDevices
 */
export interface StaleDevices {
    /**
     * Devices that are no longer active
     * @type {Array<string>}
     * @memberof StaleDevices
     */
    staleDevices?: Array<string>;
}
/**
 * 
 * @export
 * @interface StickerPackFormUploadAttributes
 */
export interface StickerPackFormUploadAttributes {
    /**
     * 
     * @type {StickerPackFormUploadItem}
     * @memberof StickerPackFormUploadAttributes
     */
    manifest?: StickerPackFormUploadItem;
    /**
     * 
     * @type {Array<StickerPackFormUploadItem>}
     * @memberof StickerPackFormUploadAttributes
     */
    stickers?: Array<StickerPackFormUploadItem>;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadAttributes
     */
    packId?: string;
}
/**
 * 
 * @export
 * @interface StickerPackFormUploadItem
 */
export interface StickerPackFormUploadItem {
    /**
     * 
     * @type {number}
     * @memberof StickerPackFormUploadItem
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    credential?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    acl?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    algorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    policy?: string;
    /**
     * 
     * @type {string}
     * @memberof StickerPackFormUploadItem
     */
    signature?: string;
}
/**
 * A page of media objects stored for this backup ID
 * @export
 * @interface StoredMediaObject
 */
export interface StoredMediaObject {
    /**
     * The backup cdn where this media object is stored
     * @type {number}
     * @memberof StoredMediaObject
     */
    cdn: number;
    /**
     * The mediaId of the object in URL-safe base64
     * @type {string}
     * @memberof StoredMediaObject
     */
    mediaId: string;
    /**
     * The length of the object in bytes
     * @type {number}
     * @memberof StoredMediaObject
     */
    objectLength: number;
}
/**
 * 
 * @export
 * @interface SubmitVerificationCodeRequest
 */
export interface SubmitVerificationCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof SubmitVerificationCodeRequest
     */
    code: string;
}
/**
 * Information about the subscription, or null if no subscription is present
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * The subscription level
     * @type {number}
     * @memberof Subscription
     */
    level?: number;
    /**
     * If present, UNIX Epoch Timestamp in seconds, can be used to calculate next billing date.
     * @type {Date}
     * @memberof Subscription
     */
    billingCycleAnchor?: Date;
    /**
     * UNIX Epoch Timestamp in seconds, when the current subscription period ends
     * @type {Date}
     * @memberof Subscription
     */
    endOfCurrentPeriod?: Date;
    /**
     * Whether there is a currently active subscription
     * @type {boolean}
     * @memberof Subscription
     */
    active?: boolean;
    /**
     * If true, an active subscription will not auto-renew at the end of the current period
     * @type {boolean}
     * @memberof Subscription
     */
    cancelAtPeriodEnd?: boolean;
    /**
     * A three-letter ISO 4217 currency code for currency used in the subscription
     * @type {string}
     * @memberof Subscription
     */
    currency?: string;
    /**
     * The amount paid for the subscription in the currency's smallest unit
     * @type {number}
     * @memberof Subscription
     */
    amount?: number;
    /**
     * The subscription's status, mapped to Stripe's statuses. trialing will never be returned
     * @type {string}
     * @memberof Subscription
     */
    status?: string;
    /**
     * The payment provider associated with the subscription
     * @type {string}
     * @memberof Subscription
     */
    processor?: Subscription.ProcessorEnum;
    /**
     * The payment method associated with the subscription
     * @type {string}
     * @memberof Subscription
     */
    paymentMethod?: Subscription.PaymentMethodEnum;
    /**
     * Whether the latest invoice for the subscription is in a non-terminal state
     * @type {boolean}
     * @memberof Subscription
     */
    paymentProcessing?: boolean;
}

/**
 * @export
 * @namespace Subscription
 */
export namespace Subscription {
    /**
     * @export
     * @enum {string}
     */
    export enum ProcessorEnum {
        STRIPE = <any> 'STRIPE',
        BRAINTREE = <any> 'BRAINTREE',
        GOOGLEPLAYBILLING = <any> 'GOOGLE_PLAY_BILLING',
        APPLEAPPSTORE = <any> 'APPLE_APP_STORE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentMethodEnum {
        UNKNOWN = <any> 'UNKNOWN',
        CARD = <any> 'CARD',
        PAYPAL = <any> 'PAYPAL',
        SEPADEBIT = <any> 'SEPA_DEBIT',
        IDEAL = <any> 'IDEAL',
        GOOGLEPLAYBILLING = <any> 'GOOGLE_PLAY_BILLING',
        APPLEAPPSTORE = <any> 'APPLE_APP_STORE'
    }
}
/**
 * The location of the transfer archive if the archive was successfully uploaded, otherwise a error indicating that  the upload has failed and the destination device should stop waiting 
 * @export
 * @interface TransferArchiveResult
 */
export interface TransferArchiveResult {
}
/**
 * 
 * @export
 * @interface TransferArchiveUploadedRequest
 */
export interface TransferArchiveUploadedRequest {
    /**
     * The ID of the device for which the transfer archive has been prepared
     * @type {string}
     * @memberof TransferArchiveUploadedRequest
     */
    destinationDeviceId?: string;
    /**
     * The timestamp, in milliseconds since the epoch, at which the destination device was created
     * @type {number}
     * @memberof TransferArchiveUploadedRequest
     */
    destinationDeviceCreated?: number;
    /**
     * 
     * @type {TransferArchiveResult}
     * @memberof TransferArchiveUploadedRequest
     */
    transferArchive: TransferArchiveResult;
}
/**
 * 
 * @export
 * @interface TurnToken
 */
export interface TurnToken {
    /**
     * 
     * @type {string}
     * @memberof TurnToken
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof TurnToken
     */
    password?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TurnToken
     */
    urls?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TurnToken
     */
    urlsWithIps?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TurnToken
     */
    hostname?: string;
}
/**
 * 
 * @export
 * @interface UpdateVerificationSessionRequest
 */
export interface UpdateVerificationSessionRequest {
    /**
     * The APNs or FCM device token to which a push challenge can be sent
     * @type {string}
     * @memberof UpdateVerificationSessionRequest
     */
    pushToken?: string;
    /**
     * The type of push token
     * @type {string}
     * @memberof UpdateVerificationSessionRequest
     */
    pushTokenType?: UpdateVerificationSessionRequest.PushTokenTypeEnum;
    /**
     * Value received by the device in the push challenge
     * @type {string}
     * @memberof UpdateVerificationSessionRequest
     */
    pushChallenge?: string;
    /**
     * Captcha token returned after solving a captcha challenge
     * @type {string}
     * @memberof UpdateVerificationSessionRequest
     */
    captcha?: string;
    /**
     * Mobile country code of the phone subscriber
     * @type {string}
     * @memberof UpdateVerificationSessionRequest
     */
    mcc?: string;
    /**
     * Mobile network code of the phone subscriber
     * @type {string}
     * @memberof UpdateVerificationSessionRequest
     */
    mnc?: string;
}

/**
 * @export
 * @namespace UpdateVerificationSessionRequest
 */
export namespace UpdateVerificationSessionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum PushTokenTypeEnum {
        Apn = <any> 'apn',
        Fcm = <any> 'fcm'
    }
}
/**
 * 
 * @export
 * @interface UploadDescriptorResponse
 */
export interface UploadDescriptorResponse {
    /**
     * Indicates the CDN type. 3 indicates resumable uploads using TUS
     * @type {number}
     * @memberof UploadDescriptorResponse
     */
    cdn?: number;
    /**
     * The location within the specified cdn where the finished upload can be found.
     * @type {string}
     * @memberof UploadDescriptorResponse
     */
    key?: string;
    /**
     * A map of headers to include with all upload requests. Potentially contains time-limited upload credentials
     * @type {{ [key: string]: string; }}
     * @memberof UploadDescriptorResponse
     */
    headers?: { [key: string]: string; };
    /**
     * The URL to upload to with the appropriate protocol
     * @type {string}
     * @memberof UploadDescriptorResponse
     */
    signedUploadLocation?: string;
}
/**
 * List of remote configurations applicable to the user
 * @export
 * @interface UserRemoteConfig
 */
export interface UserRemoteConfig {
    /**
     * Name of the configuration
     * @type {string}
     * @memberof UserRemoteConfig
     */
    name?: string;
    /**
     * Whether the configuration is enabled for the user
     * @type {boolean}
     * @memberof UserRemoteConfig
     */
    enabled?: boolean;
    /**
     * The value to be used for the configuration, if it is a non-boolean type
     * @type {string}
     * @memberof UserRemoteConfig
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface UserRemoteConfigList
 */
export interface UserRemoteConfigList {
    /**
     * List of remote configurations applicable to the user
     * @type {Array<UserRemoteConfig>}
     * @memberof UserRemoteConfigList
     */
    config?: Array<UserRemoteConfig>;
    /**
     * Timestamp when the configuration was generated. Deprecated in favor of `X-Signal-Timestamp` response header. 
     * @type {Date}
     * @memberof UserRemoteConfigList
     */
    serverEpochTime?: Date;
}
/**
 * 
 * @export
 * @interface UsernameHashMonitor
 */
export interface UsernameHashMonitor {
    /**
     * The username hash to monitor, encoded in url-safe unpadded base64.
     * @type {string}
     * @memberof UsernameHashMonitor
     */
    value: string;
    /**
     * A log tree position maintained by the client for the username hash.
     * @type {number}
     * @memberof UsernameHashMonitor
     */
    entryPosition?: number;
    /**
     * The commitment index derived from a previous search request, encoded in standard unpadded base64
     * @type {string}
     * @memberof UsernameHashMonitor
     */
    commitmentIndex: string;
}
/**
 * 
 * @export
 * @interface UsernameHashResponse
 */
export interface UsernameHashResponse {
    /**
     * The hash of the confirmed username, as supplied in the request
     * @type {string}
     * @memberof UsernameHashResponse
     */
    usernameHash?: string;
    /**
     * A handle that can be included in username links to retrieve the stored encrypted username
     * @type {string}
     * @memberof UsernameHashResponse
     */
    usernameLinkHandle?: string;
}
/**
 * 
 * @export
 * @interface UsernameLinkHandle
 */
export interface UsernameLinkHandle {
    /**
     * A handle that can be included in username links to retrieve the stored encrypted username
     * @type {string}
     * @memberof UsernameLinkHandle
     */
    usernameLinkHandle: string;
}
/**
 * 
 * @export
 * @interface V1ChallengeBody
 */
export interface V1ChallengeBody {
}
/**
 * 
 * @export
 * @interface VerificationCodeRequest
 */
export interface VerificationCodeRequest {
    /**
     * Transport via which to send the verification code
     * @type {string}
     * @memberof VerificationCodeRequest
     */
    transport: VerificationCodeRequest.TransportEnum;
    /**
     * Client type to facilitate platform-specific SMS verification
     * @type {string}
     * @memberof VerificationCodeRequest
     */
    client: string;
}

/**
 * @export
 * @namespace VerificationCodeRequest
 */
export namespace VerificationCodeRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TransportEnum {
        Sms = <any> 'sms',
        Voice = <any> 'voice'
    }
}
/**
 * 
 * @export
 * @interface VerificationSessionResponse
 */
export interface VerificationSessionResponse {
    /**
     * A URL-safe ID for the session
     * @type {string}
     * @memberof VerificationSessionResponse
     */
    id: string;
    /**
     * Duration in seconds after which next SMS can be requested for this session
     * @type {number}
     * @memberof VerificationSessionResponse
     */
    nextSms?: number;
    /**
     * Duration in seconds after which next voice call can be requested for this session
     * @type {number}
     * @memberof VerificationSessionResponse
     */
    nextCall?: number;
    /**
     * Duration in seconds after which the client can submit a verification code for this session
     * @type {number}
     * @memberof VerificationSessionResponse
     */
    nextVerificationAttempt?: number;
    /**
     * Whether it is allowed to request a verification code for this session
     * @type {boolean}
     * @memberof VerificationSessionResponse
     */
    allowedToRequestCode: boolean;
    /**
     * A list of requested information that the client needs to submit before requesting code delivery
     * @type {Array<string>}
     * @memberof VerificationSessionResponse
     */
    requestedInformation?: Array<VerificationSessionResponse.RequestedInformationEnum>;
    /**
     * Whether this session is verified
     * @type {boolean}
     * @memberof VerificationSessionResponse
     */
    verified: boolean;
}

/**
 * @export
 * @namespace VerificationSessionResponse
 */
export namespace VerificationSessionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RequestedInformationEnum {
        PushChallenge = <any> 'pushChallenge',
        Captcha = <any> 'captcha'
    }
}
/**
 * 
 * @export
 * @interface VersionedProfileResponse
 */
export interface VersionedProfileResponse {
    /**
     * 
     * @type {IdentityKey}
     * @memberof VersionedProfileResponse
     */
    identityKey?: IdentityKey;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    unidentifiedAccess?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VersionedProfileResponse
     */
    unrestrictedUnidentifiedAccess?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof VersionedProfileResponse
     */
    capabilities?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<Badge>}
     * @memberof VersionedProfileResponse
     */
    badges?: Array<Badge>;
    /**
     * A service identifier is a tuple of a UUID and identity type that identifies an account and identity within the Signal service.
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    about?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    aboutEmoji?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    paymentAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionedProfileResponse
     */
    phoneNumberSharing?: string;
}
/**
 * 
 * @export
 * @interface WebSocketClient
 */
export interface WebSocketClient {
    /**
     * 
     * @type {Date}
     * @memberof WebSocketClient
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof WebSocketClient
     */
    userAgent?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebSocketClient
     */
    open?: boolean;
}
/**
 * 
 * @export
 * @interface WebSocketSessionContext
 */
export interface WebSocketSessionContext {
    /**
     * 
     * @type {any}
     * @memberof WebSocketSessionContext
     */
    authenticated?: any;
    /**
     * 
     * @type {WebSocketClient}
     * @memberof WebSocketSessionContext
     */
    client?: WebSocketClient;
}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enforced unauthenticated endpoint. Checks whether an account with a given identifier exists. 
         * @summary Check whether an account exists
         * @param {ServiceIdentifier} identifier An ACI or PNI account identifier to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountExists(identifier: ServiceIdentifier, options: any = {}): FetchArgs {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountExists.');
            }
            const localVarPath = `/v1/accounts/account/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes a phone number for an existing account.
         * @summary Change number
         * @param {ChangeNumberRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeNumber(body: ChangeNumberRequest, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling changeNumber.');
            }
            const localVarPath = `/v2/accounts/number`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangeNumberRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticated endpoint. For a previously reserved username hash, confirm that this username hash is now taken by this account. 
         * @summary Confirm username hash
         * @param {ConfirmUsernameHashRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUsernameHash(body: ConfirmUsernameHashRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling confirmUsernameHash.');
            }
            const localVarPath = `/v1/accounts/username_hash/confirm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfirmUsernameHashRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApnRegistrationId(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/apn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcmRegistrationId(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/gcm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticated endpoint. Deletes previously stored username for the account. 
         * @summary Delete username hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsernameHash(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/username_hash`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticated endpoint. Deletes username link for the given account: previously store encrypted username is deleted and username link handle is deactivated. 
         * @summary Delete username link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsernameLink(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/username_link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates key material for the phone-number identity for all devices and sends a synchronization message to companion devices
         * @summary Set phone-number identity keys
         * @param {PhoneNumberIdentityKeyDistributionRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributePhoneNumberIdentityKeys(body: PhoneNumberIdentityKeyDistributionRequest, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling distributePhoneNumberIdentityKeys.');
            }
            const localVarPath = `/v2/accounts/phone_number_identity_key_distribution`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PhoneNumberIdentityKeyDistributionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Produces a report of non-ephemeral account data stored by the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDataReport(options: any = {}): FetchArgs {
            const localVarPath = `/v2/accounts/data_report`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forced unauthenticated endpoint. For the given username hash, look up a user ID. 
         * @summary Lookup username hash
         * @param {string} usernameHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUsernameHash(usernameHash: string, options: any = {}): FetchArgs {
            // verify required parameter 'usernameHash' is not null or undefined
            if (usernameHash === null || usernameHash === undefined) {
                throw new RequiredError('usernameHash','Required parameter usernameHash was null or undefined when calling lookupUsernameHash.');
            }
            const localVarPath = `/v1/accounts/username_hash/{usernameHash}`
                .replace(`{${"usernameHash"}}`, encodeURIComponent(String(usernameHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enforced unauthenticated endpoint. For the given username link handle, looks up the database for an associated encrypted username. If found, encrypted username is returned, otherwise responds with 404 Not Found. 
         * @summary Lookup username link
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUsernameLink(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling lookupUsernameLink.');
            }
            const localVarPath = `/v1/accounts/username_link/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRegistrationLock(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/registration_lock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticated endpoint. Takes in a list of hashes of potential username hashes, finds one that is not taken, and reserves it for the current account. 
         * @summary Reserve username hash
         * @param {ReserveUsernameHashRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveUsernameHash(body: ReserveUsernameHashRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling reserveUsernameHash.');
            }
            const localVarPath = `/v1/accounts/username_hash/reserve`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReserveUsernameHashRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountAttributes} body 
         * @param {string} [xSignalAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountAttributes(body: AccountAttributes, xSignalAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setAccountAttributes.');
            }
            const localVarPath = `/v1/accounts/attributes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalAgent !== undefined && xSignalAgent !== null) {
                localVarHeaderParameter['X-Signal-Agent'] = String(xSignalAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountAttributes" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ApnRegistrationId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setApnRegistrationId(body: ApnRegistrationId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setApnRegistrationId.');
            }
            const localVarPath = `/v1/accounts/apn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApnRegistrationId" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GcmRegistrationId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGcmRegistrationId(body: GcmRegistrationId, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setGcmRegistrationId.');
            }
            const localVarPath = `/v1/accounts/gcm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GcmRegistrationId" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the encrypted name for the specified device. Primary devices may change the name of any device associated with their account, but linked devices may only change their own name. If no device ID is specified, then the authenticated device's ID will be used. 
         * @summary Set a device's encrypted name
         * @param {DeviceName} body 
         * @param {string} [deviceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName(body: DeviceName, deviceId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setName.');
            }
            const localVarPath = `/v1/accounts/name`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeviceName" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets whether the account should be discoverable by phone number in the directory.
         * @param {PhoneNumberDiscoverabilityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhoneNumberDiscoverability(body: PhoneNumberDiscoverabilityRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setPhoneNumberDiscoverability.');
            }
            const localVarPath = `/v2/accounts/phone_number_discoverability`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PhoneNumberDiscoverabilityRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegistrationLock} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRegistrationLock(body: RegistrationLock, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setRegistrationLock.');
            }
            const localVarPath = `/v1/accounts/registration_lock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistrationLock" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticated endpoint. For the given encrypted username generates a username link handle. The username link handle can be used to lookup the encrypted username. An account can only have one username link at a time; this endpoint overwrites the previous encrypted username if there was one. 
         * @summary Set username link
         * @param {EncryptedUsername} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsernameLink(body: EncryptedUsername, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUsernameLink.');
            }
            const localVarPath = `/v1/accounts/username_link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EncryptedUsername" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(options: any = {}): FetchArgs {
            const localVarPath = `/v1/accounts/whoami`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Enforced unauthenticated endpoint. Checks whether an account with a given identifier exists. 
         * @summary Check whether an account exists
         * @param {ServiceIdentifier} identifier An ACI or PNI account identifier to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountExists(identifier: ServiceIdentifier, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountExists(identifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes a phone number for an existing account.
         * @summary Change number
         * @param {ChangeNumberRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeNumber(body: ChangeNumberRequest, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountIdentityResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).changeNumber(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticated endpoint. For a previously reserved username hash, confirm that this username hash is now taken by this account. 
         * @summary Confirm username hash
         * @param {ConfirmUsernameHashRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUsernameHash(body: ConfirmUsernameHashRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsernameHashResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).confirmUsernameHash(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteAccount(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApnRegistrationId(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteApnRegistrationId(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcmRegistrationId(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteGcmRegistrationId(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticated endpoint. Deletes previously stored username for the account. 
         * @summary Delete username hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsernameHash(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteUsernameHash(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticated endpoint. Deletes username link for the given account: previously store encrypted username is deleted and username link handle is deactivated. 
         * @summary Delete username link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsernameLink(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).deleteUsernameLink(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates key material for the phone-number identity for all devices and sends a synchronization message to companion devices
         * @summary Set phone-number identity keys
         * @param {PhoneNumberIdentityKeyDistributionRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributePhoneNumberIdentityKeys(body: PhoneNumberIdentityKeyDistributionRequest, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountIdentityResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).distributePhoneNumberIdentityKeys(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Produces a report of non-ephemeral account data stored by the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDataReport(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountDataReportResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).getAccountDataReport(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forced unauthenticated endpoint. For the given username hash, look up a user ID. 
         * @summary Lookup username hash
         * @param {string} usernameHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUsernameHash(usernameHash: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountIdentifierResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).lookupUsernameHash(usernameHash, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enforced unauthenticated endpoint. For the given username link handle, looks up the database for an associated encrypted username. If found, encrypted username is returned, otherwise responds with 404 Not Found. 
         * @summary Lookup username link
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUsernameLink(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EncryptedUsername> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).lookupUsernameLink(uuid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRegistrationLock(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).removeRegistrationLock(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticated endpoint. Takes in a list of hashes of potential username hashes, finds one that is not taken, and reserves it for the current account. 
         * @summary Reserve username hash
         * @param {ReserveUsernameHashRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveUsernameHash(body: ReserveUsernameHashRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReserveUsernameHashResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).reserveUsernameHash(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AccountAttributes} body 
         * @param {string} [xSignalAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountAttributes(body: AccountAttributes, xSignalAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).setAccountAttributes(body, xSignalAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ApnRegistrationId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setApnRegistrationId(body: ApnRegistrationId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).setApnRegistrationId(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GcmRegistrationId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGcmRegistrationId(body: GcmRegistrationId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).setGcmRegistrationId(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the encrypted name for the specified device. Primary devices may change the name of any device associated with their account, but linked devices may only change their own name. If no device ID is specified, then the authenticated device's ID will be used. 
         * @summary Set a device's encrypted name
         * @param {DeviceName} body 
         * @param {string} [deviceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName(body: DeviceName, deviceId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).setName(body, deviceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sets whether the account should be discoverable by phone number in the directory.
         * @param {PhoneNumberDiscoverabilityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhoneNumberDiscoverability(body: PhoneNumberDiscoverabilityRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).setPhoneNumberDiscoverability(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RegistrationLock} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRegistrationLock(body: RegistrationLock, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).setRegistrationLock(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticated endpoint. For the given encrypted username generates a username link handle. The username link handle can be used to lookup the encrypted username. An account can only have one username link at a time; this endpoint overwrites the previous encrypted username if there was one. 
         * @summary Set username link
         * @param {EncryptedUsername} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsernameLink(body: EncryptedUsername, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UsernameLinkHandle> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).updateUsernameLink(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountIdentityResponse> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).whoAmI(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Enforced unauthenticated endpoint. Checks whether an account with a given identifier exists. 
         * @summary Check whether an account exists
         * @param {ServiceIdentifier} identifier An ACI or PNI account identifier to check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountExists(identifier: ServiceIdentifier, options?: any) {
            return AccountApiFp(configuration).accountExists(identifier, options)(fetch, basePath);
        },
        /**
         * Changes a phone number for an existing account.
         * @summary Change number
         * @param {ChangeNumberRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeNumber(body: ChangeNumberRequest, userAgent?: string, options?: any) {
            return AccountApiFp(configuration).changeNumber(body, userAgent, options)(fetch, basePath);
        },
        /**
         * Authenticated endpoint. For a previously reserved username hash, confirm that this username hash is now taken by this account. 
         * @summary Confirm username hash
         * @param {ConfirmUsernameHashRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUsernameHash(body: ConfirmUsernameHashRequest, options?: any) {
            return AccountApiFp(configuration).confirmUsernameHash(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(options?: any) {
            return AccountApiFp(configuration).deleteAccount(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApnRegistrationId(options?: any) {
            return AccountApiFp(configuration).deleteApnRegistrationId(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGcmRegistrationId(options?: any) {
            return AccountApiFp(configuration).deleteGcmRegistrationId(options)(fetch, basePath);
        },
        /**
         * Authenticated endpoint. Deletes previously stored username for the account. 
         * @summary Delete username hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsernameHash(options?: any) {
            return AccountApiFp(configuration).deleteUsernameHash(options)(fetch, basePath);
        },
        /**
         * Authenticated endpoint. Deletes username link for the given account: previously store encrypted username is deleted and username link handle is deactivated. 
         * @summary Delete username link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsernameLink(options?: any) {
            return AccountApiFp(configuration).deleteUsernameLink(options)(fetch, basePath);
        },
        /**
         * Updates key material for the phone-number identity for all devices and sends a synchronization message to companion devices
         * @summary Set phone-number identity keys
         * @param {PhoneNumberIdentityKeyDistributionRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributePhoneNumberIdentityKeys(body: PhoneNumberIdentityKeyDistributionRequest, userAgent?: string, options?: any) {
            return AccountApiFp(configuration).distributePhoneNumberIdentityKeys(body, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Produces a report of non-ephemeral account data stored by the service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDataReport(options?: any) {
            return AccountApiFp(configuration).getAccountDataReport(options)(fetch, basePath);
        },
        /**
         * Forced unauthenticated endpoint. For the given username hash, look up a user ID. 
         * @summary Lookup username hash
         * @param {string} usernameHash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUsernameHash(usernameHash: string, options?: any) {
            return AccountApiFp(configuration).lookupUsernameHash(usernameHash, options)(fetch, basePath);
        },
        /**
         * Enforced unauthenticated endpoint. For the given username link handle, looks up the database for an associated encrypted username. If found, encrypted username is returned, otherwise responds with 404 Not Found. 
         * @summary Lookup username link
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUsernameLink(uuid: string, options?: any) {
            return AccountApiFp(configuration).lookupUsernameLink(uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRegistrationLock(options?: any) {
            return AccountApiFp(configuration).removeRegistrationLock(options)(fetch, basePath);
        },
        /**
         * Authenticated endpoint. Takes in a list of hashes of potential username hashes, finds one that is not taken, and reserves it for the current account. 
         * @summary Reserve username hash
         * @param {ReserveUsernameHashRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveUsernameHash(body: ReserveUsernameHashRequest, options?: any) {
            return AccountApiFp(configuration).reserveUsernameHash(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AccountAttributes} body 
         * @param {string} [xSignalAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAccountAttributes(body: AccountAttributes, xSignalAgent?: string, options?: any) {
            return AccountApiFp(configuration).setAccountAttributes(body, xSignalAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ApnRegistrationId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setApnRegistrationId(body: ApnRegistrationId, options?: any) {
            return AccountApiFp(configuration).setApnRegistrationId(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GcmRegistrationId} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGcmRegistrationId(body: GcmRegistrationId, options?: any) {
            return AccountApiFp(configuration).setGcmRegistrationId(body, options)(fetch, basePath);
        },
        /**
         * Sets the encrypted name for the specified device. Primary devices may change the name of any device associated with their account, but linked devices may only change their own name. If no device ID is specified, then the authenticated device's ID will be used. 
         * @summary Set a device's encrypted name
         * @param {DeviceName} body 
         * @param {string} [deviceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setName(body: DeviceName, deviceId?: string, options?: any) {
            return AccountApiFp(configuration).setName(body, deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sets whether the account should be discoverable by phone number in the directory.
         * @param {PhoneNumberDiscoverabilityRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPhoneNumberDiscoverability(body: PhoneNumberDiscoverabilityRequest, options?: any) {
            return AccountApiFp(configuration).setPhoneNumberDiscoverability(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RegistrationLock} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRegistrationLock(body: RegistrationLock, options?: any) {
            return AccountApiFp(configuration).setRegistrationLock(body, options)(fetch, basePath);
        },
        /**
         * Authenticated endpoint. For the given encrypted username generates a username link handle. The username link handle can be used to lookup the encrypted username. An account can only have one username link at a time; this endpoint overwrites the previous encrypted username if there was one. 
         * @summary Set username link
         * @param {EncryptedUsername} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsernameLink(body: EncryptedUsername, options?: any) {
            return AccountApiFp(configuration).updateUsernameLink(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoAmI(options?: any) {
            return AccountApiFp(configuration).whoAmI(options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Enforced unauthenticated endpoint. Checks whether an account with a given identifier exists. 
     * @summary Check whether an account exists
     * @param {ServiceIdentifier} identifier An ACI or PNI account identifier to check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountExists(identifier: ServiceIdentifier, options?: any) {
        return AccountApiFp(this.configuration).accountExists(identifier, options)(this.fetch, this.basePath);
    }

    /**
     * Changes a phone number for an existing account.
     * @summary Change number
     * @param {ChangeNumberRequest} body 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public changeNumber(body: ChangeNumberRequest, userAgent?: string, options?: any) {
        return AccountApiFp(this.configuration).changeNumber(body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Authenticated endpoint. For a previously reserved username hash, confirm that this username hash is now taken by this account. 
     * @summary Confirm username hash
     * @param {ConfirmUsernameHashRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public confirmUsernameHash(body: ConfirmUsernameHashRequest, options?: any) {
        return AccountApiFp(this.configuration).confirmUsernameHash(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccount(options?: any) {
        return AccountApiFp(this.configuration).deleteAccount(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteApnRegistrationId(options?: any) {
        return AccountApiFp(this.configuration).deleteApnRegistrationId(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteGcmRegistrationId(options?: any) {
        return AccountApiFp(this.configuration).deleteGcmRegistrationId(options)(this.fetch, this.basePath);
    }

    /**
     * Authenticated endpoint. Deletes previously stored username for the account. 
     * @summary Delete username hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteUsernameHash(options?: any) {
        return AccountApiFp(this.configuration).deleteUsernameHash(options)(this.fetch, this.basePath);
    }

    /**
     * Authenticated endpoint. Deletes username link for the given account: previously store encrypted username is deleted and username link handle is deactivated. 
     * @summary Delete username link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteUsernameLink(options?: any) {
        return AccountApiFp(this.configuration).deleteUsernameLink(options)(this.fetch, this.basePath);
    }

    /**
     * Updates key material for the phone-number identity for all devices and sends a synchronization message to companion devices
     * @summary Set phone-number identity keys
     * @param {PhoneNumberIdentityKeyDistributionRequest} body 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public distributePhoneNumberIdentityKeys(body: PhoneNumberIdentityKeyDistributionRequest, userAgent?: string, options?: any) {
        return AccountApiFp(this.configuration).distributePhoneNumberIdentityKeys(body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Produces a report of non-ephemeral account data stored by the service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccountDataReport(options?: any) {
        return AccountApiFp(this.configuration).getAccountDataReport(options)(this.fetch, this.basePath);
    }

    /**
     * Forced unauthenticated endpoint. For the given username hash, look up a user ID. 
     * @summary Lookup username hash
     * @param {string} usernameHash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public lookupUsernameHash(usernameHash: string, options?: any) {
        return AccountApiFp(this.configuration).lookupUsernameHash(usernameHash, options)(this.fetch, this.basePath);
    }

    /**
     * Enforced unauthenticated endpoint. For the given username link handle, looks up the database for an associated encrypted username. If found, encrypted username is returned, otherwise responds with 404 Not Found. 
     * @summary Lookup username link
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public lookupUsernameLink(uuid: string, options?: any) {
        return AccountApiFp(this.configuration).lookupUsernameLink(uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public removeRegistrationLock(options?: any) {
        return AccountApiFp(this.configuration).removeRegistrationLock(options)(this.fetch, this.basePath);
    }

    /**
     * Authenticated endpoint. Takes in a list of hashes of potential username hashes, finds one that is not taken, and reserves it for the current account. 
     * @summary Reserve username hash
     * @param {ReserveUsernameHashRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public reserveUsernameHash(body: ReserveUsernameHashRequest, options?: any) {
        return AccountApiFp(this.configuration).reserveUsernameHash(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AccountAttributes} body 
     * @param {string} [xSignalAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setAccountAttributes(body: AccountAttributes, xSignalAgent?: string, options?: any) {
        return AccountApiFp(this.configuration).setAccountAttributes(body, xSignalAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ApnRegistrationId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setApnRegistrationId(body: ApnRegistrationId, options?: any) {
        return AccountApiFp(this.configuration).setApnRegistrationId(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {GcmRegistrationId} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setGcmRegistrationId(body: GcmRegistrationId, options?: any) {
        return AccountApiFp(this.configuration).setGcmRegistrationId(body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the encrypted name for the specified device. Primary devices may change the name of any device associated with their account, but linked devices may only change their own name. If no device ID is specified, then the authenticated device's ID will be used. 
     * @summary Set a device's encrypted name
     * @param {DeviceName} body 
     * @param {string} [deviceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setName(body: DeviceName, deviceId?: string, options?: any) {
        return AccountApiFp(this.configuration).setName(body, deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sets whether the account should be discoverable by phone number in the directory.
     * @param {PhoneNumberDiscoverabilityRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setPhoneNumberDiscoverability(body: PhoneNumberDiscoverabilityRequest, options?: any) {
        return AccountApiFp(this.configuration).setPhoneNumberDiscoverability(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RegistrationLock} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public setRegistrationLock(body: RegistrationLock, options?: any) {
        return AccountApiFp(this.configuration).setRegistrationLock(body, options)(this.fetch, this.basePath);
    }

    /**
     * Authenticated endpoint. For the given encrypted username generates a username link handle. The username link handle can be used to lookup the encrypted username. An account can only have one username link at a time; this endpoint overwrites the previous encrypted username if there was one. 
     * @summary Set username link
     * @param {EncryptedUsername} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateUsernameLink(body: EncryptedUsername, options?: any) {
        return AccountApiFp(this.configuration).updateUsernameLink(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public whoAmI(options?: any) {
        return AccountApiFp(this.configuration).whoAmI(options)(this.fetch, this.basePath);
    }

}
/**
 * ArchiveApi - fetch parameter creator
 * @export
 */
export const ArchiveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an upload form that can be used to perform a resumable upload of a message backup.
         * @summary Fetch message backup upload form
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling backup.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling backup.');
            }
            const localVarPath = `/v1/archives/upload/form`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve information about the currently stored backup
         * @summary Fetch backup info
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupInfo(xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling backupInfo.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling backupInfo.');
            }
            const localVarPath = `/v1/archives`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original already encrypted attachment will be encrypted with the provided key material before being copied  If the batch request is processed at all, a 207 will be returned and the outcome of each constituent copy will be provided as a separate entry in the response. 
         * @summary Batched backup media
         * @param {CopyMediaBatchRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyMedia(body: CopyMediaBatchRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling copyMedia.');
            }
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling copyMedia.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling copyMedia.');
            }
            const localVarPath = `/v1/archives/media/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CopyMediaBatchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original, already encrypted, attachment will be encrypted with the provided key material before being copied.  A particular destination media id should not be reused with a different source media id or different encryption parameters. 
         * @summary Backup media
         * @param {CopyMediaRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyMedia1(body: CopyMediaRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling copyMedia1.');
            }
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling copyMedia1.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling copyMedia1.');
            }
            const localVarPath = `/v1/archives/media`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CopyMediaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all backup metadata, objects, and stored public key. To use backups again, a public key must be resupplied. 
         * @summary Delete entire backup
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling deleteBackup.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling deleteBackup.');
            }
            const localVarPath = `/v1/archives`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete media objects stored with this backup-id
         * @summary Delete media objects
         * @param {DeleteMedia} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMedia(body: DeleteMedia, xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteMedia.');
            }
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling deleteMedia.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling deleteMedia.');
            }
            const localVarPath = `/v1/archives/media/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteMedia" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After setting a blinded backup-id with PUT /v1/archives/, this fetches credentials that can be used to perform operations against that backup-id. Clients may (and should) request up to 7 days of credentials at a time.  The redemptionStart and redemptionEnd seconds must be UTC day aligned, and must not span more than 7 days.  Each credential contains a receipt level which indicates the backup level the credential is good for. If the account has paid backup access that expires at some point in the provided redemption window, credentials with redemption times after the expiration may be on a lower backup level.  Clients must validate the receipt level on the credential matches a known receipt level before using it. 
         * @summary Fetch ZK credentials 
         * @param {number} redemptionStartSeconds 
         * @param {number} redemptionEndSeconds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupZKCredentials(redemptionStartSeconds: number, redemptionEndSeconds: number, options: any = {}): FetchArgs {
            // verify required parameter 'redemptionStartSeconds' is not null or undefined
            if (redemptionStartSeconds === null || redemptionStartSeconds === undefined) {
                throw new RequiredError('redemptionStartSeconds','Required parameter redemptionStartSeconds was null or undefined when calling getBackupZKCredentials.');
            }
            // verify required parameter 'redemptionEndSeconds' is not null or undefined
            if (redemptionEndSeconds === null || redemptionEndSeconds === undefined) {
                throw new RequiredError('redemptionEndSeconds','Required parameter redemptionEndSeconds was null or undefined when calling getBackupZKCredentials.');
            }
            const localVarPath = `/v1/archives/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (redemptionStartSeconds !== undefined) {
                localVarQueryParameter['redemptionStartSeconds'] = redemptionStartSeconds;
            }

            if (redemptionEndSeconds !== undefined) {
                localVarQueryParameter['redemptionEndSeconds'] = redemptionEndSeconds;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of media objects stored for this backup-id. A client may have previously stored media objects that are no longer referenced in their current backup. To reclaim storage space used by these orphaned objects, perform a list operation and remove any unreferenced media objects via DELETE /v1/backups/<mediaId>. 
         * @summary List media objects
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {string} [cursor] A cursor returned by a previous call
         * @param {number} [limit] The number of entries to return per call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMedia(xSignalZKAuth: string, xSignalZKAuthSignature: string, cursor?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling listMedia.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling listMedia.');
            }
            const localVarPath = `/v1/archives/media`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve credentials used to read objects stored on the backup cdn
         * @summary Get CDN read credentials
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {number} cdn The number of the CDN to get credentials for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuth(xSignalZKAuth: string, xSignalZKAuthSignature: string, cdn: number, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling readAuth.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling readAuth.');
            }
            // verify required parameter 'cdn' is not null or undefined
            if (cdn === null || cdn === undefined) {
                throw new RequiredError('cdn','Required parameter cdn was null or undefined when calling readAuth.');
            }
            const localVarPath = `/v1/archives/auth/read`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (cdn !== undefined) {
                localVarQueryParameter['cdn'] = cdn;
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redeem a receipt acquired from /v1/subscription/{subscriberId}/receipt_credentials to mark the account as eligible for the paid backup tier.  After successful redemption, subsequent requests to /v1/archive/auth will return credentials with the level on the provided receipt until the expiration time on the receipt. 
         * @summary Redeem receipt
         * @param {RedeemBackupReceiptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReceipt(body: RedeemBackupReceiptRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling redeemReceipt.');
            }
            const localVarPath = `/v1/archives/redeem-receipt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RedeemBackupReceiptRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Indicate that this backup is still active. Clients must periodically upload new backups or perform a refresh via a POST request. If a backup is not refreshed, after 30 days it may be deleted. 
         * @summary Refresh backup
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling refresh.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling refresh.');
            }
            const localVarPath = `/v1/archives`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a (blinded) backup-id for the account. Each account may have a single active backup-id that can be used to store and retrieve backups. Once the backup-id is set, BackupAuthCredentials can be generated using /v1/archives/auth.  The blinded backup-id and the key-pair used to blind it should be derived from a recoverable secret. 
         * @summary Set backup id
         * @param {SetBackupIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupId(body: SetBackupIdRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setBackupId.');
            }
            const localVarPath = `/v1/archives/backupid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetBackupIdRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently set the public key of an ED25519 key-pair for the backup-id. All requests that provide a anonymous BackupAuthCredentialPresentation (including this one!) must also sign the presentation with the private key corresponding to the provided public key. 
         * @summary Set public key
         * @param {SetPublicKeyRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicKey(body: SetPublicKeyRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setPublicKey.');
            }
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling setPublicKey.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling setPublicKey.');
            }
            const localVarPath = `/v1/archives/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetPublicKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an upload form that can be used to perform a resumable upload of an attachment. After uploading, the attachment can be copied into the backup at PUT /archives/media/.  Like the account authenticated version at /attachments, the uploaded object is only temporary. 
         * @summary Fetch media attachment upload form
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryAttachment(xSignalZKAuth: string, xSignalZKAuthSignature: string, options: any = {}): FetchArgs {
            // verify required parameter 'xSignalZKAuth' is not null or undefined
            if (xSignalZKAuth === null || xSignalZKAuth === undefined) {
                throw new RequiredError('xSignalZKAuth','Required parameter xSignalZKAuth was null or undefined when calling uploadTemporaryAttachment.');
            }
            // verify required parameter 'xSignalZKAuthSignature' is not null or undefined
            if (xSignalZKAuthSignature === null || xSignalZKAuthSignature === undefined) {
                throw new RequiredError('xSignalZKAuthSignature','Required parameter xSignalZKAuthSignature was null or undefined when calling uploadTemporaryAttachment.');
            }
            const localVarPath = `/v1/archives/media/upload/form`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalZKAuth !== undefined && xSignalZKAuth !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth'] = String(xSignalZKAuth);
            }

            if (xSignalZKAuthSignature !== undefined && xSignalZKAuthSignature !== null) {
                localVarHeaderParameter['X-Signal-ZK-Auth-Signature'] = String(xSignalZKAuthSignature);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArchiveApi - functional programming interface
 * @export
 */
export const ArchiveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve an upload form that can be used to perform a resumable upload of a message backup.
         * @summary Fetch message backup upload form
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadDescriptorResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).backup(xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve information about the currently stored backup
         * @summary Fetch backup info
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupInfo(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BackupInfoResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).backupInfo(xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original already encrypted attachment will be encrypted with the provided key material before being copied  If the batch request is processed at all, a 207 will be returned and the outcome of each constituent copy will be provided as a separate entry in the response. 
         * @summary Batched backup media
         * @param {CopyMediaBatchRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyMedia(body: CopyMediaBatchRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CopyMediaBatchResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).copyMedia(body, xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original, already encrypted, attachment will be encrypted with the provided key material before being copied.  A particular destination media id should not be reused with a different source media id or different encryption parameters. 
         * @summary Backup media
         * @param {CopyMediaRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyMedia1(body: CopyMediaRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CopyMediaResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).copyMedia1(body, xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete all backup metadata, objects, and stored public key. To use backups again, a public key must be resupplied. 
         * @summary Delete entire backup
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).deleteBackup(xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete media objects stored with this backup-id
         * @summary Delete media objects
         * @param {DeleteMedia} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMedia(body: DeleteMedia, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).deleteMedia(body, xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * After setting a blinded backup-id with PUT /v1/archives/, this fetches credentials that can be used to perform operations against that backup-id. Clients may (and should) request up to 7 days of credentials at a time.  The redemptionStart and redemptionEnd seconds must be UTC day aligned, and must not span more than 7 days.  Each credential contains a receipt level which indicates the backup level the credential is good for. If the account has paid backup access that expires at some point in the provided redemption window, credentials with redemption times after the expiration may be on a lower backup level.  Clients must validate the receipt level on the credential matches a known receipt level before using it. 
         * @summary Fetch ZK credentials 
         * @param {number} redemptionStartSeconds 
         * @param {number} redemptionEndSeconds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupZKCredentials(redemptionStartSeconds: number, redemptionEndSeconds: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BackupAuthCredentialsResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).getBackupZKCredentials(redemptionStartSeconds, redemptionEndSeconds, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a list of media objects stored for this backup-id. A client may have previously stored media objects that are no longer referenced in their current backup. To reclaim storage space used by these orphaned objects, perform a list operation and remove any unreferenced media objects via DELETE /v1/backups/<mediaId>. 
         * @summary List media objects
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {string} [cursor] A cursor returned by a previous call
         * @param {number} [limit] The number of entries to return per call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMedia(xSignalZKAuth: string, xSignalZKAuthSignature: string, cursor?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).listMedia(xSignalZKAuth, xSignalZKAuthSignature, cursor, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve credentials used to read objects stored on the backup cdn
         * @summary Get CDN read credentials
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {number} cdn The number of the CDN to get credentials for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuth(xSignalZKAuth: string, xSignalZKAuthSignature: string, cdn: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ReadAuthResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).readAuth(xSignalZKAuth, xSignalZKAuthSignature, cdn, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Redeem a receipt acquired from /v1/subscription/{subscriberId}/receipt_credentials to mark the account as eligible for the paid backup tier.  After successful redemption, subsequent requests to /v1/archive/auth will return credentials with the level on the provided receipt until the expiration time on the receipt. 
         * @summary Redeem receipt
         * @param {RedeemBackupReceiptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReceipt(body: RedeemBackupReceiptRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).redeemReceipt(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Indicate that this backup is still active. Clients must periodically upload new backups or perform a refresh via a POST request. If a backup is not refreshed, after 30 days it may be deleted. 
         * @summary Refresh backup
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).refresh(xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set a (blinded) backup-id for the account. Each account may have a single active backup-id that can be used to store and retrieve backups. Once the backup-id is set, BackupAuthCredentials can be generated using /v1/archives/auth.  The blinded backup-id and the key-pair used to blind it should be derived from a recoverable secret. 
         * @summary Set backup id
         * @param {SetBackupIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupId(body: SetBackupIdRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).setBackupId(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently set the public key of an ED25519 key-pair for the backup-id. All requests that provide a anonymous BackupAuthCredentialPresentation (including this one!) must also sign the presentation with the private key corresponding to the provided public key. 
         * @summary Set public key
         * @param {SetPublicKeyRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicKey(body: SetPublicKeyRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).setPublicKey(body, xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve an upload form that can be used to perform a resumable upload of an attachment. After uploading, the attachment can be copied into the backup at PUT /archives/media/.  Like the account authenticated version at /attachments, the uploaded object is only temporary. 
         * @summary Fetch media attachment upload form
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryAttachment(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UploadDescriptorResponse> {
            const localVarFetchArgs = ArchiveApiFetchParamCreator(configuration).uploadTemporaryAttachment(xSignalZKAuth, xSignalZKAuthSignature, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArchiveApi - factory interface
 * @export
 */
export const ArchiveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve an upload form that can be used to perform a resumable upload of a message backup.
         * @summary Fetch message backup upload form
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).backup(xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Retrieve information about the currently stored backup
         * @summary Fetch backup info
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupInfo(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).backupInfo(xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original already encrypted attachment will be encrypted with the provided key material before being copied  If the batch request is processed at all, a 207 will be returned and the outcome of each constituent copy will be provided as a separate entry in the response. 
         * @summary Batched backup media
         * @param {CopyMediaBatchRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyMedia(body: CopyMediaBatchRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).copyMedia(body, xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original, already encrypted, attachment will be encrypted with the provided key material before being copied.  A particular destination media id should not be reused with a different source media id or different encryption parameters. 
         * @summary Backup media
         * @param {CopyMediaRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyMedia1(body: CopyMediaRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).copyMedia1(body, xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Delete all backup metadata, objects, and stored public key. To use backups again, a public key must be resupplied. 
         * @summary Delete entire backup
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBackup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).deleteBackup(xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Delete media objects stored with this backup-id
         * @summary Delete media objects
         * @param {DeleteMedia} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMedia(body: DeleteMedia, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).deleteMedia(body, xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * After setting a blinded backup-id with PUT /v1/archives/, this fetches credentials that can be used to perform operations against that backup-id. Clients may (and should) request up to 7 days of credentials at a time.  The redemptionStart and redemptionEnd seconds must be UTC day aligned, and must not span more than 7 days.  Each credential contains a receipt level which indicates the backup level the credential is good for. If the account has paid backup access that expires at some point in the provided redemption window, credentials with redemption times after the expiration may be on a lower backup level.  Clients must validate the receipt level on the credential matches a known receipt level before using it. 
         * @summary Fetch ZK credentials 
         * @param {number} redemptionStartSeconds 
         * @param {number} redemptionEndSeconds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackupZKCredentials(redemptionStartSeconds: number, redemptionEndSeconds: number, options?: any) {
            return ArchiveApiFp(configuration).getBackupZKCredentials(redemptionStartSeconds, redemptionEndSeconds, options)(fetch, basePath);
        },
        /**
         * Retrieve a list of media objects stored for this backup-id. A client may have previously stored media objects that are no longer referenced in their current backup. To reclaim storage space used by these orphaned objects, perform a list operation and remove any unreferenced media objects via DELETE /v1/backups/<mediaId>. 
         * @summary List media objects
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {string} [cursor] A cursor returned by a previous call
         * @param {number} [limit] The number of entries to return per call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMedia(xSignalZKAuth: string, xSignalZKAuthSignature: string, cursor?: string, limit?: number, options?: any) {
            return ArchiveApiFp(configuration).listMedia(xSignalZKAuth, xSignalZKAuthSignature, cursor, limit, options)(fetch, basePath);
        },
        /**
         * Retrieve credentials used to read objects stored on the backup cdn
         * @summary Get CDN read credentials
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {number} cdn The number of the CDN to get credentials for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAuth(xSignalZKAuth: string, xSignalZKAuthSignature: string, cdn: number, options?: any) {
            return ArchiveApiFp(configuration).readAuth(xSignalZKAuth, xSignalZKAuthSignature, cdn, options)(fetch, basePath);
        },
        /**
         * Redeem a receipt acquired from /v1/subscription/{subscriberId}/receipt_credentials to mark the account as eligible for the paid backup tier.  After successful redemption, subsequent requests to /v1/archive/auth will return credentials with the level on the provided receipt until the expiration time on the receipt. 
         * @summary Redeem receipt
         * @param {RedeemBackupReceiptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReceipt(body: RedeemBackupReceiptRequest, options?: any) {
            return ArchiveApiFp(configuration).redeemReceipt(body, options)(fetch, basePath);
        },
        /**
         * Indicate that this backup is still active. Clients must periodically upload new backups or perform a refresh via a POST request. If a backup is not refreshed, after 30 days it may be deleted. 
         * @summary Refresh backup
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).refresh(xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Set a (blinded) backup-id for the account. Each account may have a single active backup-id that can be used to store and retrieve backups. Once the backup-id is set, BackupAuthCredentials can be generated using /v1/archives/auth.  The blinded backup-id and the key-pair used to blind it should be derived from a recoverable secret. 
         * @summary Set backup id
         * @param {SetBackupIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBackupId(body: SetBackupIdRequest, options?: any) {
            return ArchiveApiFp(configuration).setBackupId(body, options)(fetch, basePath);
        },
        /**
         * Permanently set the public key of an ED25519 key-pair for the backup-id. All requests that provide a anonymous BackupAuthCredentialPresentation (including this one!) must also sign the presentation with the private key corresponding to the provided public key. 
         * @summary Set public key
         * @param {SetPublicKeyRequest} body 
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicKey(body: SetPublicKeyRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).setPublicKey(body, xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
        /**
         * Retrieve an upload form that can be used to perform a resumable upload of an attachment. After uploading, the attachment can be copied into the backup at PUT /archives/media/.  Like the account authenticated version at /attachments, the uploaded object is only temporary. 
         * @summary Fetch media attachment upload form
         * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
         * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTemporaryAttachment(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
            return ArchiveApiFp(configuration).uploadTemporaryAttachment(xSignalZKAuth, xSignalZKAuthSignature, options)(fetch, basePath);
        },
    };
};

/**
 * ArchiveApi - object-oriented interface
 * @export
 * @class ArchiveApi
 * @extends {BaseAPI}
 */
export class ArchiveApi extends BaseAPI {
    /**
     * Retrieve an upload form that can be used to perform a resumable upload of a message backup.
     * @summary Fetch message backup upload form
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public backup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).backup(xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve information about the currently stored backup
     * @summary Fetch backup info
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public backupInfo(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).backupInfo(xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original already encrypted attachment will be encrypted with the provided key material before being copied  If the batch request is processed at all, a 207 will be returned and the outcome of each constituent copy will be provided as a separate entry in the response. 
     * @summary Batched backup media
     * @param {CopyMediaBatchRequest} body 
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public copyMedia(body: CopyMediaBatchRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).copyMedia(body, xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Copy and re-encrypt media from the attachments cdn into the backup cdn.  The original, already encrypted, attachment will be encrypted with the provided key material before being copied.  A particular destination media id should not be reused with a different source media id or different encryption parameters. 
     * @summary Backup media
     * @param {CopyMediaRequest} body 
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public copyMedia1(body: CopyMediaRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).copyMedia1(body, xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Delete all backup metadata, objects, and stored public key. To use backups again, a public key must be resupplied. 
     * @summary Delete entire backup
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public deleteBackup(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).deleteBackup(xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Delete media objects stored with this backup-id
     * @summary Delete media objects
     * @param {DeleteMedia} body 
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public deleteMedia(body: DeleteMedia, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).deleteMedia(body, xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * After setting a blinded backup-id with PUT /v1/archives/, this fetches credentials that can be used to perform operations against that backup-id. Clients may (and should) request up to 7 days of credentials at a time.  The redemptionStart and redemptionEnd seconds must be UTC day aligned, and must not span more than 7 days.  Each credential contains a receipt level which indicates the backup level the credential is good for. If the account has paid backup access that expires at some point in the provided redemption window, credentials with redemption times after the expiration may be on a lower backup level.  Clients must validate the receipt level on the credential matches a known receipt level before using it. 
     * @summary Fetch ZK credentials 
     * @param {number} redemptionStartSeconds 
     * @param {number} redemptionEndSeconds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public getBackupZKCredentials(redemptionStartSeconds: number, redemptionEndSeconds: number, options?: any) {
        return ArchiveApiFp(this.configuration).getBackupZKCredentials(redemptionStartSeconds, redemptionEndSeconds, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a list of media objects stored for this backup-id. A client may have previously stored media objects that are no longer referenced in their current backup. To reclaim storage space used by these orphaned objects, perform a list operation and remove any unreferenced media objects via DELETE /v1/backups/<mediaId>. 
     * @summary List media objects
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {string} [cursor] A cursor returned by a previous call
     * @param {number} [limit] The number of entries to return per call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public listMedia(xSignalZKAuth: string, xSignalZKAuthSignature: string, cursor?: string, limit?: number, options?: any) {
        return ArchiveApiFp(this.configuration).listMedia(xSignalZKAuth, xSignalZKAuthSignature, cursor, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve credentials used to read objects stored on the backup cdn
     * @summary Get CDN read credentials
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {number} cdn The number of the CDN to get credentials for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public readAuth(xSignalZKAuth: string, xSignalZKAuthSignature: string, cdn: number, options?: any) {
        return ArchiveApiFp(this.configuration).readAuth(xSignalZKAuth, xSignalZKAuthSignature, cdn, options)(this.fetch, this.basePath);
    }

    /**
     * Redeem a receipt acquired from /v1/subscription/{subscriberId}/receipt_credentials to mark the account as eligible for the paid backup tier.  After successful redemption, subsequent requests to /v1/archive/auth will return credentials with the level on the provided receipt until the expiration time on the receipt. 
     * @summary Redeem receipt
     * @param {RedeemBackupReceiptRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public redeemReceipt(body: RedeemBackupReceiptRequest, options?: any) {
        return ArchiveApiFp(this.configuration).redeemReceipt(body, options)(this.fetch, this.basePath);
    }

    /**
     * Indicate that this backup is still active. Clients must periodically upload new backups or perform a refresh via a POST request. If a backup is not refreshed, after 30 days it may be deleted. 
     * @summary Refresh backup
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public refresh(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).refresh(xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Set a (blinded) backup-id for the account. Each account may have a single active backup-id that can be used to store and retrieve backups. Once the backup-id is set, BackupAuthCredentials can be generated using /v1/archives/auth.  The blinded backup-id and the key-pair used to blind it should be derived from a recoverable secret. 
     * @summary Set backup id
     * @param {SetBackupIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public setBackupId(body: SetBackupIdRequest, options?: any) {
        return ArchiveApiFp(this.configuration).setBackupId(body, options)(this.fetch, this.basePath);
    }

    /**
     * Permanently set the public key of an ED25519 key-pair for the backup-id. All requests that provide a anonymous BackupAuthCredentialPresentation (including this one!) must also sign the presentation with the private key corresponding to the provided public key. 
     * @summary Set public key
     * @param {SetPublicKeyRequest} body 
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public setPublicKey(body: SetPublicKeyRequest, xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).setPublicKey(body, xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve an upload form that can be used to perform a resumable upload of an attachment. After uploading, the attachment can be copied into the backup at PUT /archives/media/.  Like the account authenticated version at /attachments, the uploaded object is only temporary. 
     * @summary Fetch media attachment upload form
     * @param {string} xSignalZKAuth Presentation of a ZK backup auth credential acquired from /v1/archives/auth, encoded in standard padded base64
     * @param {string} xSignalZKAuthSignature Signature of the ZK auth credential&#x27;s presentation, encoded in standard padded base64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArchiveApi
     */
    public uploadTemporaryAttachment(xSignalZKAuth: string, xSignalZKAuthSignature: string, options?: any) {
        return ArchiveApiFp(this.configuration).uploadTemporaryAttachment(xSignalZKAuth, xSignalZKAuthSignature, options)(this.fetch, this.basePath);
    }

}
/**
 * AttachmentsApi - fetch parameter creator
 * @export
 */
export const AttachmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an upload form that can be used to perform a resumable upload. The response will include a cdn number indicating what protocol should be used to perform the upload. 
         * @summary Get an upload form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentUploadForm(options: any = {}): FetchArgs {
            const localVarPath = `/v4/attachments/form/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve an upload form that can be used to perform a resumable upload. The response will include a cdn number indicating what protocol should be used to perform the upload. 
         * @summary Get an upload form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentUploadForm(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentDescriptorV3> {
            const localVarFetchArgs = AttachmentsApiFetchParamCreator(configuration).getAttachmentUploadForm(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve an upload form that can be used to perform a resumable upload. The response will include a cdn number indicating what protocol should be used to perform the upload. 
         * @summary Get an upload form
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentUploadForm(options?: any) {
            return AttachmentsApiFp(configuration).getAttachmentUploadForm(options)(fetch, basePath);
        },
    };
};

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * Retrieve an upload form that can be used to perform a resumable upload. The response will include a cdn number indicating what protocol should be used to perform the upload. 
     * @summary Get an upload form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public getAttachmentUploadForm(options?: any) {
        return AttachmentsApiFp(this.configuration).getAttachmentUploadForm(options)(this.fetch, this.basePath);
    }

}
/**
 * CallLinkApi - fetch parameter creator
 * @export
 */
export const CallLinkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a credential over a truncated timestamp, room ID, and account UUID. With zero knowledge group infrastructure, the server does not know the room ID. 
         * @summary Generate a credential for creating call links
         * @param {GetCreateCallLinkCredentialsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreateAuth(body: GetCreateCallLinkCredentialsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling getCreateAuth.');
            }
            const localVarPath = `/v1/call-link/create-auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetCreateCallLinkCredentialsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallLinkApi - functional programming interface
 * @export
 */
export const CallLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generate a credential over a truncated timestamp, room ID, and account UUID. With zero knowledge group infrastructure, the server does not know the room ID. 
         * @summary Generate a credential for creating call links
         * @param {GetCreateCallLinkCredentialsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreateAuth(body: GetCreateCallLinkCredentialsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateCallLinkCredential> {
            const localVarFetchArgs = CallLinkApiFetchParamCreator(configuration).getCreateAuth(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallLinkApi - factory interface
 * @export
 */
export const CallLinkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generate a credential over a truncated timestamp, room ID, and account UUID. With zero knowledge group infrastructure, the server does not know the room ID. 
         * @summary Generate a credential for creating call links
         * @param {GetCreateCallLinkCredentialsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCreateAuth(body: GetCreateCallLinkCredentialsRequest, options?: any) {
            return CallLinkApiFp(configuration).getCreateAuth(body, options)(fetch, basePath);
        },
    };
};

/**
 * CallLinkApi - object-oriented interface
 * @export
 * @class CallLinkApi
 * @extends {BaseAPI}
 */
export class CallLinkApi extends BaseAPI {
    /**
     * Generate a credential over a truncated timestamp, room ID, and account UUID. With zero knowledge group infrastructure, the server does not know the room ID. 
     * @summary Generate a credential for creating call links
     * @param {GetCreateCallLinkCredentialsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallLinkApi
     */
    public getCreateAuth(body: GetCreateCallLinkCredentialsRequest, options?: any) {
        return CallLinkApiFp(this.configuration).getCreateAuth(body, options)(this.fetch, this.basePath);
    }

}
/**
 * CallingApi - fetch parameter creator
 * @export
 */
export const CallingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get 1:1 relay addresses in IpV4, Ipv6, and URL formats. 
         * @summary Get 1:1 calling relay options for the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallingRelays(options: any = {}): FetchArgs {
            const localVarPath = `/v2/calling/relays`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallingApi - functional programming interface
 * @export
 */
export const CallingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get 1:1 relay addresses in IpV4, Ipv6, and URL formats. 
         * @summary Get 1:1 calling relay options for the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallingRelays(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetCallingRelaysResponse> {
            const localVarFetchArgs = CallingApiFetchParamCreator(configuration).getCallingRelays(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CallingApi - factory interface
 * @export
 */
export const CallingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get 1:1 relay addresses in IpV4, Ipv6, and URL formats. 
         * @summary Get 1:1 calling relay options for the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCallingRelays(options?: any) {
            return CallingApiFp(configuration).getCallingRelays(options)(fetch, basePath);
        },
    };
};

/**
 * CallingApi - object-oriented interface
 * @export
 * @class CallingApi
 * @extends {BaseAPI}
 */
export class CallingApi extends BaseAPI {
    /**
     * Get 1:1 relay addresses in IpV4, Ipv6, and URL formats. 
     * @summary Get 1:1 calling relay options for the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallingApi
     */
    public getCallingRelays(options?: any) {
        return CallingApiFp(this.configuration).getCallingRelays(options)(this.fetch, this.basePath);
    }

}
/**
 * CertificateApi - fetch parameter creator
 * @export
 */
export const CertificateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [includeE164] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeliveryCertificate(includeE164?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v1/certificate/delivery`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (includeE164 !== undefined) {
                localVarQueryParameter['includeE164'] = includeE164;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userAgent] 
         * @param {number} [redemptionStartSeconds] 
         * @param {number} [redemptionEndSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuthenticationCredentials(userAgent?: string, redemptionStartSeconds?: number, redemptionEndSeconds?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/certificate/auth/group`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (redemptionStartSeconds !== undefined) {
                localVarQueryParameter['redemptionStartSeconds'] = redemptionStartSeconds;
            }

            if (redemptionEndSeconds !== undefined) {
                localVarQueryParameter['redemptionEndSeconds'] = redemptionEndSeconds;
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CertificateApi - functional programming interface
 * @export
 */
export const CertificateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [includeE164] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeliveryCertificate(includeE164?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeliveryCertificate> {
            const localVarFetchArgs = CertificateApiFetchParamCreator(configuration).getDeliveryCertificate(includeE164, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [userAgent] 
         * @param {number} [redemptionStartSeconds] 
         * @param {number} [redemptionEndSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuthenticationCredentials(userAgent?: string, redemptionStartSeconds?: number, redemptionEndSeconds?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupCredentials> {
            const localVarFetchArgs = CertificateApiFetchParamCreator(configuration).getGroupAuthenticationCredentials(userAgent, redemptionStartSeconds, redemptionEndSeconds, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CertificateApi - factory interface
 * @export
 */
export const CertificateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {boolean} [includeE164] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeliveryCertificate(includeE164?: boolean, options?: any) {
            return CertificateApiFp(configuration).getDeliveryCertificate(includeE164, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [userAgent] 
         * @param {number} [redemptionStartSeconds] 
         * @param {number} [redemptionEndSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupAuthenticationCredentials(userAgent?: string, redemptionStartSeconds?: number, redemptionEndSeconds?: number, options?: any) {
            return CertificateApiFp(configuration).getGroupAuthenticationCredentials(userAgent, redemptionStartSeconds, redemptionEndSeconds, options)(fetch, basePath);
        },
    };
};

/**
 * CertificateApi - object-oriented interface
 * @export
 * @class CertificateApi
 * @extends {BaseAPI}
 */
export class CertificateApi extends BaseAPI {
    /**
     * 
     * @param {boolean} [includeE164] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public getDeliveryCertificate(includeE164?: boolean, options?: any) {
        return CertificateApiFp(this.configuration).getDeliveryCertificate(includeE164, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [userAgent] 
     * @param {number} [redemptionStartSeconds] 
     * @param {number} [redemptionEndSeconds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CertificateApi
     */
    public getGroupAuthenticationCredentials(userAgent?: string, redemptionStartSeconds?: number, redemptionEndSeconds?: number, options?: any) {
        return CertificateApiFp(this.configuration).getGroupAuthenticationCredentials(userAgent, redemptionStartSeconds, redemptionEndSeconds, options)(this.fetch, this.basePath);
    }

}
/**
 * ChallengeApi - fetch parameter creator
 * @export
 */
export const ChallengeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Some server endpoints (the \"send message\" endpoint, for example) may return a 428 response indicating the client must complete a challenge before continuing. Clients may use this endpoint to provide proof of a completed challenge. If successful, the client may then continue their original operation. 
         * @summary Submit proof of a challenge completion
         * @param {V1ChallengeBody} [body] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleChallengeResponse(body?: V1ChallengeBody, userAgent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/challenge`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V1ChallengeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clients may proactively request a push challenge by making an empty POST request. Push challenges will only be sent to the requesting account’s main device. When the push is received it may be provided as proof of completed challenge to /v1/challenge. APNs challenge payloads will be formatted as follows: ``` {     \"aps\": {         \"sound\": \"default\",         \"alert\": {             \"loc-key\": \"APN_Message\"         }     },     \"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\" } ``` FCM challenge payloads will be formatted as follows: ``` {\"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\"} ```  Clients may retry the PUT in the event of an HTTP/5xx response (except HTTP/508) from the server, but must implement an exponential back-off system and limit the total number of retries. 
         * @summary Request a push challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPushChallenge(options: any = {}): FetchArgs {
            const localVarPath = `/v1/challenge/push`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChallengeApi - functional programming interface
 * @export
 */
export const ChallengeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Some server endpoints (the \"send message\" endpoint, for example) may return a 428 response indicating the client must complete a challenge before continuing. Clients may use this endpoint to provide proof of a completed challenge. If successful, the client may then continue their original operation. 
         * @summary Submit proof of a challenge completion
         * @param {V1ChallengeBody} [body] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleChallengeResponse(body?: V1ChallengeBody, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChallengeApiFetchParamCreator(configuration).handleChallengeResponse(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Clients may proactively request a push challenge by making an empty POST request. Push challenges will only be sent to the requesting account’s main device. When the push is received it may be provided as proof of completed challenge to /v1/challenge. APNs challenge payloads will be formatted as follows: ``` {     \"aps\": {         \"sound\": \"default\",         \"alert\": {             \"loc-key\": \"APN_Message\"         }     },     \"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\" } ``` FCM challenge payloads will be formatted as follows: ``` {\"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\"} ```  Clients may retry the PUT in the event of an HTTP/5xx response (except HTTP/508) from the server, but must implement an exponential back-off system and limit the total number of retries. 
         * @summary Request a push challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPushChallenge(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ChallengeApiFetchParamCreator(configuration).requestPushChallenge(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChallengeApi - factory interface
 * @export
 */
export const ChallengeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Some server endpoints (the \"send message\" endpoint, for example) may return a 428 response indicating the client must complete a challenge before continuing. Clients may use this endpoint to provide proof of a completed challenge. If successful, the client may then continue their original operation. 
         * @summary Submit proof of a challenge completion
         * @param {V1ChallengeBody} [body] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleChallengeResponse(body?: V1ChallengeBody, userAgent?: string, options?: any) {
            return ChallengeApiFp(configuration).handleChallengeResponse(body, userAgent, options)(fetch, basePath);
        },
        /**
         * Clients may proactively request a push challenge by making an empty POST request. Push challenges will only be sent to the requesting account’s main device. When the push is received it may be provided as proof of completed challenge to /v1/challenge. APNs challenge payloads will be formatted as follows: ``` {     \"aps\": {         \"sound\": \"default\",         \"alert\": {             \"loc-key\": \"APN_Message\"         }     },     \"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\" } ``` FCM challenge payloads will be formatted as follows: ``` {\"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\"} ```  Clients may retry the PUT in the event of an HTTP/5xx response (except HTTP/508) from the server, but must implement an exponential back-off system and limit the total number of retries. 
         * @summary Request a push challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPushChallenge(options?: any) {
            return ChallengeApiFp(configuration).requestPushChallenge(options)(fetch, basePath);
        },
    };
};

/**
 * ChallengeApi - object-oriented interface
 * @export
 * @class ChallengeApi
 * @extends {BaseAPI}
 */
export class ChallengeApi extends BaseAPI {
    /**
     * Some server endpoints (the \"send message\" endpoint, for example) may return a 428 response indicating the client must complete a challenge before continuing. Clients may use this endpoint to provide proof of a completed challenge. If successful, the client may then continue their original operation. 
     * @summary Submit proof of a challenge completion
     * @param {V1ChallengeBody} [body] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public handleChallengeResponse(body?: V1ChallengeBody, userAgent?: string, options?: any) {
        return ChallengeApiFp(this.configuration).handleChallengeResponse(body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Clients may proactively request a push challenge by making an empty POST request. Push challenges will only be sent to the requesting account’s main device. When the push is received it may be provided as proof of completed challenge to /v1/challenge. APNs challenge payloads will be formatted as follows: ``` {     \"aps\": {         \"sound\": \"default\",         \"alert\": {             \"loc-key\": \"APN_Message\"         }     },     \"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\" } ``` FCM challenge payloads will be formatted as follows: ``` {\"rateLimitChallenge\": \"{CHALLENGE_TOKEN}\"} ```  Clients may retry the PUT in the event of an HTTP/5xx response (except HTTP/508) from the server, but must implement an exponential back-off system and limit the total number of retries. 
     * @summary Request a push challenge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChallengeApi
     */
    public requestPushChallenge(options?: any) {
        return ChallengeApiFp(this.configuration).requestPushChallenge(options)(this.fetch, this.basePath);
    }

}
/**
 * DeviceCheckApi - fetch parameter creator
 * @export
 */
export const DeviceCheckApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a challenge to use in an attestation, which must be provided at `POST /v1/devicecheck/assert`. To produce the `clientDataHash` for [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)), construct the request you intend to `POST` and include the returned challenge as the \"challenge\" field. Serialize the request as JSON and take the SHA256 of the request, as described [here](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity#Assert-your-apps-validity-as-necessary). Note that the JSON body provided to the PUT must exactly match the input to the `clientDataHash` (field order, whitespace, etc matters)  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `POST`. Callers should attempt to only have a single outstanding challenge at any given time. 
         * @summary Fetch an assert challenge
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertChallenge(action?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/devicecheck/assert`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specify some action to take on the account via the request field. The request must exactly match the request you provide when [generating the assertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)). The request must include a challenge previously retrieved from `GET /v1/devicecheck/assert`.  Each assertion increments the counter associated with the client's device key. This method enforces that no assertion with a counter lower than a counter we've already seen is allowed to execute. If a client issues multiple requests concurrently, or if they retry a request that had an indeterminate outcome, it's possible that the request will not be accepted because the server has already stored the updated counter. In this case the request may return 401, and the client should generate a fresh assert for the request. 
         * @summary Perform an attested action
         * @param {string} keyId The keyId, encoded with padded url-safe base64
         * @param {AssertionRequest} request The asserted JSON request data, encoded as a string in padded url-safe base64. This must exactly match the request you use when generating the assertion (including field ordering, whitespace, etc). 
         * @param {string} [body] The assertion created by [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertion(keyId: string, request: AssertionRequest, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling assertion.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling assertion.');
            }
            const localVarPath = `/v1/devicecheck/assert`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyId !== undefined) {
                localVarQueryParameter['keyId'] = keyId;
            }

            if (request !== undefined) {
                localVarQueryParameter['request'] = request;
            }

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a keyId with an attestation, which can be used to generate assertions from this account.  The attestation should use the SHA-256 of a challenge retrieved at `GET /v1/devicecheck/attest` as the `clientDataHash`  Registration is idempotent, and you should retry network errors with the same challenge as suggested by [device check](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)#discussion), as long as your challenge has not expired (410). Even if your challenge is expired, you may continue to retry with your original keyId (and a fresh challenge). 
         * @summary Register a keyId
         * @param {string} keyId The keyId, encoded with padded url-safe base64
         * @param {string} [body] The attestation data, created by [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attest(keyId: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId','Required parameter keyId was null or undefined when calling attest.');
            }
            const localVarPath = `/v1/devicecheck/attest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (keyId !== undefined) {
                localVarQueryParameter['keyId'] = keyId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a challenge to use in an attestation, which should be provided at `PUT /v1/devicecheck/attest`. To produce the clientDataHash for [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)) take the SHA256 of the UTF-8 bytes of the returned challenge.  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `PUT`. Callers should have a single outstanding challenge at any given time. 
         * @summary Fetch an attest challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attestChallenge(options: any = {}): FetchArgs {
            const localVarPath = `/v1/devicecheck/attest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceCheckApi - functional programming interface
 * @export
 */
export const DeviceCheckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve a challenge to use in an attestation, which must be provided at `POST /v1/devicecheck/assert`. To produce the `clientDataHash` for [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)), construct the request you intend to `POST` and include the returned challenge as the \"challenge\" field. Serialize the request as JSON and take the SHA256 of the request, as described [here](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity#Assert-your-apps-validity-as-necessary). Note that the JSON body provided to the PUT must exactly match the input to the `clientDataHash` (field order, whitespace, etc matters)  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `POST`. Callers should attempt to only have a single outstanding challenge at any given time. 
         * @summary Fetch an assert challenge
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertChallenge(action?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceCheckApiFetchParamCreator(configuration).assertChallenge(action, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Specify some action to take on the account via the request field. The request must exactly match the request you provide when [generating the assertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)). The request must include a challenge previously retrieved from `GET /v1/devicecheck/assert`.  Each assertion increments the counter associated with the client's device key. This method enforces that no assertion with a counter lower than a counter we've already seen is allowed to execute. If a client issues multiple requests concurrently, or if they retry a request that had an indeterminate outcome, it's possible that the request will not be accepted because the server has already stored the updated counter. In this case the request may return 401, and the client should generate a fresh assert for the request. 
         * @summary Perform an attested action
         * @param {string} keyId The keyId, encoded with padded url-safe base64
         * @param {AssertionRequest} request The asserted JSON request data, encoded as a string in padded url-safe base64. This must exactly match the request you use when generating the assertion (including field ordering, whitespace, etc). 
         * @param {string} [body] The assertion created by [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertion(keyId: string, request: AssertionRequest, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceCheckApiFetchParamCreator(configuration).assertion(keyId, request, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Register a keyId with an attestation, which can be used to generate assertions from this account.  The attestation should use the SHA-256 of a challenge retrieved at `GET /v1/devicecheck/attest` as the `clientDataHash`  Registration is idempotent, and you should retry network errors with the same challenge as suggested by [device check](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)#discussion), as long as your challenge has not expired (410). Even if your challenge is expired, you may continue to retry with your original keyId (and a fresh challenge). 
         * @summary Register a keyId
         * @param {string} keyId The keyId, encoded with padded url-safe base64
         * @param {string} [body] The attestation data, created by [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attest(keyId: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceCheckApiFetchParamCreator(configuration).attest(keyId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve a challenge to use in an attestation, which should be provided at `PUT /v1/devicecheck/attest`. To produce the clientDataHash for [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)) take the SHA256 of the UTF-8 bytes of the returned challenge.  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `PUT`. Callers should have a single outstanding challenge at any given time. 
         * @summary Fetch an attest challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attestChallenge(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeviceCheckApiFetchParamCreator(configuration).attestChallenge(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceCheckApi - factory interface
 * @export
 */
export const DeviceCheckApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve a challenge to use in an attestation, which must be provided at `POST /v1/devicecheck/assert`. To produce the `clientDataHash` for [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)), construct the request you intend to `POST` and include the returned challenge as the \"challenge\" field. Serialize the request as JSON and take the SHA256 of the request, as described [here](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity#Assert-your-apps-validity-as-necessary). Note that the JSON body provided to the PUT must exactly match the input to the `clientDataHash` (field order, whitespace, etc matters)  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `POST`. Callers should attempt to only have a single outstanding challenge at any given time. 
         * @summary Fetch an assert challenge
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertChallenge(action?: string, options?: any) {
            return DeviceCheckApiFp(configuration).assertChallenge(action, options)(fetch, basePath);
        },
        /**
         * Specify some action to take on the account via the request field. The request must exactly match the request you provide when [generating the assertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)). The request must include a challenge previously retrieved from `GET /v1/devicecheck/assert`.  Each assertion increments the counter associated with the client's device key. This method enforces that no assertion with a counter lower than a counter we've already seen is allowed to execute. If a client issues multiple requests concurrently, or if they retry a request that had an indeterminate outcome, it's possible that the request will not be accepted because the server has already stored the updated counter. In this case the request may return 401, and the client should generate a fresh assert for the request. 
         * @summary Perform an attested action
         * @param {string} keyId The keyId, encoded with padded url-safe base64
         * @param {AssertionRequest} request The asserted JSON request data, encoded as a string in padded url-safe base64. This must exactly match the request you use when generating the assertion (including field ordering, whitespace, etc). 
         * @param {string} [body] The assertion created by [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assertion(keyId: string, request: AssertionRequest, body?: string, options?: any) {
            return DeviceCheckApiFp(configuration).assertion(keyId, request, body, options)(fetch, basePath);
        },
        /**
         * Register a keyId with an attestation, which can be used to generate assertions from this account.  The attestation should use the SHA-256 of a challenge retrieved at `GET /v1/devicecheck/attest` as the `clientDataHash`  Registration is idempotent, and you should retry network errors with the same challenge as suggested by [device check](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)#discussion), as long as your challenge has not expired (410). Even if your challenge is expired, you may continue to retry with your original keyId (and a fresh challenge). 
         * @summary Register a keyId
         * @param {string} keyId The keyId, encoded with padded url-safe base64
         * @param {string} [body] The attestation data, created by [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:))
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attest(keyId: string, body?: string, options?: any) {
            return DeviceCheckApiFp(configuration).attest(keyId, body, options)(fetch, basePath);
        },
        /**
         * Retrieve a challenge to use in an attestation, which should be provided at `PUT /v1/devicecheck/attest`. To produce the clientDataHash for [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)) take the SHA256 of the UTF-8 bytes of the returned challenge.  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `PUT`. Callers should have a single outstanding challenge at any given time. 
         * @summary Fetch an attest challenge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attestChallenge(options?: any) {
            return DeviceCheckApiFp(configuration).attestChallenge(options)(fetch, basePath);
        },
    };
};

/**
 * DeviceCheckApi - object-oriented interface
 * @export
 * @class DeviceCheckApi
 * @extends {BaseAPI}
 */
export class DeviceCheckApi extends BaseAPI {
    /**
     * Retrieve a challenge to use in an attestation, which must be provided at `POST /v1/devicecheck/assert`. To produce the `clientDataHash` for [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)), construct the request you intend to `POST` and include the returned challenge as the \"challenge\" field. Serialize the request as JSON and take the SHA256 of the request, as described [here](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity#Assert-your-apps-validity-as-necessary). Note that the JSON body provided to the PUT must exactly match the input to the `clientDataHash` (field order, whitespace, etc matters)  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `POST`. Callers should attempt to only have a single outstanding challenge at any given time. 
     * @summary Fetch an assert challenge
     * @param {string} [action] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceCheckApi
     */
    public assertChallenge(action?: string, options?: any) {
        return DeviceCheckApiFp(this.configuration).assertChallenge(action, options)(this.fetch, this.basePath);
    }

    /**
     * Specify some action to take on the account via the request field. The request must exactly match the request you provide when [generating the assertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:)). The request must include a challenge previously retrieved from `GET /v1/devicecheck/assert`.  Each assertion increments the counter associated with the client's device key. This method enforces that no assertion with a counter lower than a counter we've already seen is allowed to execute. If a client issues multiple requests concurrently, or if they retry a request that had an indeterminate outcome, it's possible that the request will not be accepted because the server has already stored the updated counter. In this case the request may return 401, and the client should generate a fresh assert for the request. 
     * @summary Perform an attested action
     * @param {string} keyId The keyId, encoded with padded url-safe base64
     * @param {AssertionRequest} request The asserted JSON request data, encoded as a string in padded url-safe base64. This must exactly match the request you use when generating the assertion (including field ordering, whitespace, etc). 
     * @param {string} [body] The assertion created by [generateAssertion](https://developer.apple.com/documentation/devicecheck/dcappattestservice/generateassertion(_:clientdatahash:completionhandler:))
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceCheckApi
     */
    public assertion(keyId: string, request: AssertionRequest, body?: string, options?: any) {
        return DeviceCheckApiFp(this.configuration).assertion(keyId, request, body, options)(this.fetch, this.basePath);
    }

    /**
     * Register a keyId with an attestation, which can be used to generate assertions from this account.  The attestation should use the SHA-256 of a challenge retrieved at `GET /v1/devicecheck/attest` as the `clientDataHash`  Registration is idempotent, and you should retry network errors with the same challenge as suggested by [device check](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)#discussion), as long as your challenge has not expired (410). Even if your challenge is expired, you may continue to retry with your original keyId (and a fresh challenge). 
     * @summary Register a keyId
     * @param {string} keyId The keyId, encoded with padded url-safe base64
     * @param {string} [body] The attestation data, created by [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:))
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceCheckApi
     */
    public attest(keyId: string, body?: string, options?: any) {
        return DeviceCheckApiFp(this.configuration).attest(keyId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve a challenge to use in an attestation, which should be provided at `PUT /v1/devicecheck/attest`. To produce the clientDataHash for [attestKey](https://developer.apple.com/documentation/devicecheck/dcappattestservice/attestkey(_:clientdatahash:completionhandler:)) take the SHA256 of the UTF-8 bytes of the returned challenge.  Repeat calls to retrieve a challenge may return the same challenge until it is used in a `PUT`. Callers should have a single outstanding challenge at any given time. 
     * @summary Fetch an attest challenge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceCheckApi
     */
    public attestChallenge(options?: any) {
        return DeviceCheckApiFp(this.configuration).attestChallenge(options)(this.fetch, this.basePath);
    }

}
/**
 * DevicesApi - fetch parameter creator
 * @export
 */
export const DevicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a signed device-linking token for transmission to a pending linked device via a provisioning message. 
         * @summary Generate a signed device-linking token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceToken(options: any = {}): FetchArgs {
            const localVarPath = `/v1/devices/provisioning/code`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(options: any = {}): FetchArgs {
            const localVarPath = `/v1/devices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Links a device to an account identified by a given phone number. 
         * @summary Link a device to an account
         * @param {LinkDeviceRequest} body 
         * @param {BasicAuthorizationHeader} [authorization] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDevice(body: LinkDeviceRequest, authorization?: BasicAuthorizationHeader, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling linkDevice.');
            }
            const localVarPath = `/v1/devices/link`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LinkDeviceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Signals that a new device is requesting restoration of account data by some method. Devices waiting via the \"wait for 'restore account' request\" endpoint will be notified that the request has been issued. 
         * @summary Signals that a new device is requesting restoration of account data by some method
         * @param {string} token 
         * @param {RestoreAccountRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordRestoreAccountRequest(token: string, body?: RestoreAccountRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling recordRestoreAccountRequest.');
            }
            const localVarPath = `/v1/devices/restore_account/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestoreAccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Signals that a transfer archive has been uploaded or failed for a specific linked device. Devices waiting via the \"wait for transfer archive\" endpoint will be notified that the new archive is available.  If the uploader cannot upload the transfer archive, they must signal an error. 
         * @summary Signals that a transfer archive has been uploaded for a specific linked device
         * @param {TransferArchiveUploadedRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordTransferArchiveUploaded(body: TransferArchiveUploadedRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling recordTransferArchiveUploaded.');
            }
            const localVarPath = `/v1/devices/transfer_archive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TransferArchiveUploadedRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDevice(deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling removeDevice.');
            }
            const localVarPath = `/v1/devices/{device_id}`
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: boolean; }} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCapabilities(body: { [key: string]: boolean; }, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setCapabilities.');
            }
            const localVarPath = `/v1/devices/capabilities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"{ [key: string]: boolean; }" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the authentication public key for the authenticated device. The public key will be used for authentication in the nascent gRPC-over-Noise API. Existing devices must upload a public key before they can use the gRPC-over-Noise API, and this endpoint exists to facilitate migration to the new API. 
         * @summary Sets a public key for authentication
         * @param {SetPublicKeyRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicKey1(body?: SetPublicKeyRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/devices/public_key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetPublicKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Wait for 'restore account' request
         * @param {string} token 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForDeviceTransferRequest(token: string, timeout?: number, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling waitForDeviceTransferRequest.');
            }
            const localVarPath = `/v1/devices/restore_account/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Waits for a new device to be linked to an account and returns basic information about the new device when available. 
         * @summary Wait for a new device to be linked to an account
         * @param {string} tokenIdentifier 
         * @param {number} [timeout] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLinkedDevice(tokenIdentifier: string, timeout?: number, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenIdentifier' is not null or undefined
            if (tokenIdentifier === null || tokenIdentifier === undefined) {
                throw new RequiredError('tokenIdentifier','Required parameter tokenIdentifier was null or undefined when calling waitForLinkedDevice.');
            }
            const localVarPath = `/v1/devices/wait_for_linked_device/{tokenIdentifier}`
                .replace(`{${"tokenIdentifier"}}`, encodeURIComponent(String(tokenIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Waits for a new transfer archive to be uploaded for the authenticated device and returns the location of the archive when available. 
         * @summary Wait for a new transfer archive to be uploaded
         * @param {number} [timeout] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForTransferArchive(timeout?: number, userAgent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/devices/transfer_archive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generate a signed device-linking token for transmission to a pending linked device via a provisioning message. 
         * @summary Generate a signed device-linking token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LinkDeviceToken> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).createDeviceToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceInfoList> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).getDevices(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Links a device to an account identified by a given phone number. 
         * @summary Link a device to an account
         * @param {LinkDeviceRequest} body 
         * @param {BasicAuthorizationHeader} [authorization] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDevice(body: LinkDeviceRequest, authorization?: BasicAuthorizationHeader, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LinkDeviceResponse> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).linkDevice(body, authorization, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Signals that a new device is requesting restoration of account data by some method. Devices waiting via the \"wait for 'restore account' request\" endpoint will be notified that the request has been issued. 
         * @summary Signals that a new device is requesting restoration of account data by some method
         * @param {string} token 
         * @param {RestoreAccountRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordRestoreAccountRequest(token: string, body?: RestoreAccountRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).recordRestoreAccountRequest(token, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Signals that a transfer archive has been uploaded or failed for a specific linked device. Devices waiting via the \"wait for transfer archive\" endpoint will be notified that the new archive is available.  If the uploader cannot upload the transfer archive, they must signal an error. 
         * @summary Signals that a transfer archive has been uploaded for a specific linked device
         * @param {TransferArchiveUploadedRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordTransferArchiveUploaded(body: TransferArchiveUploadedRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).recordTransferArchiveUploaded(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDevice(deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).removeDevice(deviceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {{ [key: string]: boolean; }} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCapabilities(body: { [key: string]: boolean; }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).setCapabilities(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the authentication public key for the authenticated device. The public key will be used for authentication in the nascent gRPC-over-Noise API. Existing devices must upload a public key before they can use the gRPC-over-Noise API, and this endpoint exists to facilitate migration to the new API. 
         * @summary Sets a public key for authentication
         * @param {SetPublicKeyRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicKey1(body?: SetPublicKeyRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).setPublicKey1(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Wait for 'restore account' request
         * @param {string} token 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForDeviceTransferRequest(token: string, timeout?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RestoreAccountRequest> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).waitForDeviceTransferRequest(token, timeout, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Waits for a new device to be linked to an account and returns basic information about the new device when available. 
         * @summary Wait for a new device to be linked to an account
         * @param {string} tokenIdentifier 
         * @param {number} [timeout] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLinkedDevice(tokenIdentifier: string, timeout?: number, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceInfo> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).waitForLinkedDevice(tokenIdentifier, timeout, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Waits for a new transfer archive to be uploaded for the authenticated device and returns the location of the archive when available. 
         * @summary Wait for a new transfer archive to be uploaded
         * @param {number} [timeout] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForTransferArchive(timeout?: number, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = DevicesApiFetchParamCreator(configuration).waitForTransferArchive(timeout, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generate a signed device-linking token for transmission to a pending linked device via a provisioning message. 
         * @summary Generate a signed device-linking token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeviceToken(options?: any) {
            return DevicesApiFp(configuration).createDeviceToken(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(options?: any) {
            return DevicesApiFp(configuration).getDevices(options)(fetch, basePath);
        },
        /**
         * Links a device to an account identified by a given phone number. 
         * @summary Link a device to an account
         * @param {LinkDeviceRequest} body 
         * @param {BasicAuthorizationHeader} [authorization] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDevice(body: LinkDeviceRequest, authorization?: BasicAuthorizationHeader, userAgent?: string, options?: any) {
            return DevicesApiFp(configuration).linkDevice(body, authorization, userAgent, options)(fetch, basePath);
        },
        /**
         * Signals that a new device is requesting restoration of account data by some method. Devices waiting via the \"wait for 'restore account' request\" endpoint will be notified that the request has been issued. 
         * @summary Signals that a new device is requesting restoration of account data by some method
         * @param {string} token 
         * @param {RestoreAccountRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordRestoreAccountRequest(token: string, body?: RestoreAccountRequest, options?: any) {
            return DevicesApiFp(configuration).recordRestoreAccountRequest(token, body, options)(fetch, basePath);
        },
        /**
         * Signals that a transfer archive has been uploaded or failed for a specific linked device. Devices waiting via the \"wait for transfer archive\" endpoint will be notified that the new archive is available.  If the uploader cannot upload the transfer archive, they must signal an error. 
         * @summary Signals that a transfer archive has been uploaded for a specific linked device
         * @param {TransferArchiveUploadedRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordTransferArchiveUploaded(body: TransferArchiveUploadedRequest, options?: any) {
            return DevicesApiFp(configuration).recordTransferArchiveUploaded(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDevice(deviceId: string, options?: any) {
            return DevicesApiFp(configuration).removeDevice(deviceId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {{ [key: string]: boolean; }} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCapabilities(body: { [key: string]: boolean; }, options?: any) {
            return DevicesApiFp(configuration).setCapabilities(body, options)(fetch, basePath);
        },
        /**
         * Sets the authentication public key for the authenticated device. The public key will be used for authentication in the nascent gRPC-over-Noise API. Existing devices must upload a public key before they can use the gRPC-over-Noise API, and this endpoint exists to facilitate migration to the new API. 
         * @summary Sets a public key for authentication
         * @param {SetPublicKeyRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublicKey1(body?: SetPublicKeyRequest, options?: any) {
            return DevicesApiFp(configuration).setPublicKey1(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Wait for 'restore account' request
         * @param {string} token 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForDeviceTransferRequest(token: string, timeout?: number, options?: any) {
            return DevicesApiFp(configuration).waitForDeviceTransferRequest(token, timeout, options)(fetch, basePath);
        },
        /**
         * Waits for a new device to be linked to an account and returns basic information about the new device when available. 
         * @summary Wait for a new device to be linked to an account
         * @param {string} tokenIdentifier 
         * @param {number} [timeout] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLinkedDevice(tokenIdentifier: string, timeout?: number, userAgent?: string, options?: any) {
            return DevicesApiFp(configuration).waitForLinkedDevice(tokenIdentifier, timeout, userAgent, options)(fetch, basePath);
        },
        /**
         * Waits for a new transfer archive to be uploaded for the authenticated device and returns the location of the archive when available. 
         * @summary Wait for a new transfer archive to be uploaded
         * @param {number} [timeout] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForTransferArchive(timeout?: number, userAgent?: string, options?: any) {
            return DevicesApiFp(configuration).waitForTransferArchive(timeout, userAgent, options)(fetch, basePath);
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Generate a signed device-linking token for transmission to a pending linked device via a provisioning message. 
     * @summary Generate a signed device-linking token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public createDeviceToken(options?: any) {
        return DevicesApiFp(this.configuration).createDeviceToken(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(options?: any) {
        return DevicesApiFp(this.configuration).getDevices(options)(this.fetch, this.basePath);
    }

    /**
     * Links a device to an account identified by a given phone number. 
     * @summary Link a device to an account
     * @param {LinkDeviceRequest} body 
     * @param {BasicAuthorizationHeader} [authorization] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public linkDevice(body: LinkDeviceRequest, authorization?: BasicAuthorizationHeader, userAgent?: string, options?: any) {
        return DevicesApiFp(this.configuration).linkDevice(body, authorization, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Signals that a new device is requesting restoration of account data by some method. Devices waiting via the \"wait for 'restore account' request\" endpoint will be notified that the request has been issued. 
     * @summary Signals that a new device is requesting restoration of account data by some method
     * @param {string} token 
     * @param {RestoreAccountRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public recordRestoreAccountRequest(token: string, body?: RestoreAccountRequest, options?: any) {
        return DevicesApiFp(this.configuration).recordRestoreAccountRequest(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * Signals that a transfer archive has been uploaded or failed for a specific linked device. Devices waiting via the \"wait for transfer archive\" endpoint will be notified that the new archive is available.  If the uploader cannot upload the transfer archive, they must signal an error. 
     * @summary Signals that a transfer archive has been uploaded for a specific linked device
     * @param {TransferArchiveUploadedRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public recordTransferArchiveUploaded(body: TransferArchiveUploadedRequest, options?: any) {
        return DevicesApiFp(this.configuration).recordTransferArchiveUploaded(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public removeDevice(deviceId: string, options?: any) {
        return DevicesApiFp(this.configuration).removeDevice(deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {{ [key: string]: boolean; }} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public setCapabilities(body: { [key: string]: boolean; }, options?: any) {
        return DevicesApiFp(this.configuration).setCapabilities(body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the authentication public key for the authenticated device. The public key will be used for authentication in the nascent gRPC-over-Noise API. Existing devices must upload a public key before they can use the gRPC-over-Noise API, and this endpoint exists to facilitate migration to the new API. 
     * @summary Sets a public key for authentication
     * @param {SetPublicKeyRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public setPublicKey1(body?: SetPublicKeyRequest, options?: any) {
        return DevicesApiFp(this.configuration).setPublicKey1(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Wait for 'restore account' request
     * @param {string} token 
     * @param {number} [timeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public waitForDeviceTransferRequest(token: string, timeout?: number, options?: any) {
        return DevicesApiFp(this.configuration).waitForDeviceTransferRequest(token, timeout, options)(this.fetch, this.basePath);
    }

    /**
     * Waits for a new device to be linked to an account and returns basic information about the new device when available. 
     * @summary Wait for a new device to be linked to an account
     * @param {string} tokenIdentifier 
     * @param {number} [timeout] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public waitForLinkedDevice(tokenIdentifier: string, timeout?: number, userAgent?: string, options?: any) {
        return DevicesApiFp(this.configuration).waitForLinkedDevice(tokenIdentifier, timeout, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Waits for a new transfer archive to be uploaded for the authenticated device and returns the location of the archive when available. 
     * @summary Wait for a new transfer archive to be uploaded
     * @param {number} [timeout] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public waitForTransferArchive(timeout?: number, userAgent?: string, options?: any) {
        return DevicesApiFp(this.configuration).waitForTransferArchive(timeout, userAgent, options)(this.fetch, this.basePath);
    }

}
/**
 * DirectoryApi - fetch parameter creator
 * @export
 */
export const DirectoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate Contact Discovery Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
         * @summary Generate credentials for Contact Discovery Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthToken(options: any = {}): FetchArgs {
            const localVarPath = `/v2/directory/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectoryApi - functional programming interface
 * @export
 */
export const DirectoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generate Contact Discovery Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
         * @summary Generate credentials for Contact Discovery Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExternalServiceCredentials> {
            const localVarFetchArgs = DirectoryApiFetchParamCreator(configuration).getAuthToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DirectoryApi - factory interface
 * @export
 */
export const DirectoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generate Contact Discovery Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
         * @summary Generate credentials for Contact Discovery Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthToken(options?: any) {
            return DirectoryApiFp(configuration).getAuthToken(options)(fetch, basePath);
        },
    };
};

/**
 * DirectoryApi - object-oriented interface
 * @export
 * @class DirectoryApi
 * @extends {BaseAPI}
 */
export class DirectoryApi extends BaseAPI {
    /**
     * Generate Contact Discovery Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
     * @summary Generate credentials for Contact Discovery Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectoryApi
     */
    public getAuthToken(options?: any) {
        return DirectoryApiFp(this.configuration).getAuthToken(options)(this.fetch, this.basePath);
    }

}
/**
 * DonationsApi - fetch parameter creator
 * @export
 */
export const DonationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RedeemReceiptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReceipt1(body: RedeemReceiptRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling redeemReceipt1.');
            }
            const localVarPath = `/v1/donation/redeem-receipt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RedeemReceiptRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DonationsApi - functional programming interface
 * @export
 */
export const DonationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RedeemReceiptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReceipt1(body: RedeemReceiptRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DonationsApiFetchParamCreator(configuration).redeemReceipt1(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DonationsApi - factory interface
 * @export
 */
export const DonationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {RedeemReceiptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemReceipt1(body: RedeemReceiptRequest, options?: any) {
            return DonationsApiFp(configuration).redeemReceipt1(body, options)(fetch, basePath);
        },
    };
};

/**
 * DonationsApi - object-oriented interface
 * @export
 * @class DonationsApi
 * @extends {BaseAPI}
 */
export class DonationsApi extends BaseAPI {
    /**
     * 
     * @param {RedeemReceiptRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationsApi
     */
    public redeemReceipt1(body: RedeemReceiptRequest, options?: any) {
        return DonationsApiFp(this.configuration).redeemReceipt1(body, options)(this.fetch, this.basePath);
    }

}
/**
 * KeepAliveApi - fetch parameter creator
 * @export
 */
export const KeepAliveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WebSocketSessionContext} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeepAlive(body?: WebSocketSessionContext, options: any = {}): FetchArgs {
            const localVarPath = `/v1/keepalive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebSocketSessionContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningKeepAlive(options: any = {}): FetchArgs {
            const localVarPath = `/v1/keepalive/provisioning`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeepAliveApi - functional programming interface
 * @export
 */
export const KeepAliveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WebSocketSessionContext} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeepAlive(body?: WebSocketSessionContext, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeepAliveApiFetchParamCreator(configuration).getKeepAlive(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningKeepAlive(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeepAliveApiFetchParamCreator(configuration).getProvisioningKeepAlive(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KeepAliveApi - factory interface
 * @export
 */
export const KeepAliveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {WebSocketSessionContext} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeepAlive(body?: WebSocketSessionContext, options?: any) {
            return KeepAliveApiFp(configuration).getKeepAlive(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvisioningKeepAlive(options?: any) {
            return KeepAliveApiFp(configuration).getProvisioningKeepAlive(options)(fetch, basePath);
        },
    };
};

/**
 * KeepAliveApi - object-oriented interface
 * @export
 * @class KeepAliveApi
 * @extends {BaseAPI}
 */
export class KeepAliveApi extends BaseAPI {
    /**
     * 
     * @param {WebSocketSessionContext} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepAliveApi
     */
    public getKeepAlive(body?: WebSocketSessionContext, options?: any) {
        return KeepAliveApiFp(this.configuration).getKeepAlive(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeepAliveApi
     */
    public getProvisioningKeepAlive(options?: any) {
        return KeepAliveApiFp(this.configuration).getProvisioningKeepAlive(options)(this.fetch, this.basePath);
    }

}
/**
 * KeyTransparencyApi - fetch parameter creator
 * @export
 */
export const KeyTransparencyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The response contains the distinguished tree head to prove consistency against for future calls to `/search`, `/monitor`, and `/distinguished`. Enforced unauthenticated endpoint. 
         * @summary Get the current value of the distinguished key
         * @param {number} [lastTreeHeadSize] The distinguished tree head size returned by a previously verified call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinguishedKey(lastTreeHeadSize?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/key-transparency/distinguished`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (lastTreeHeadSize !== undefined) {
                localVarQueryParameter['lastTreeHeadSize'] = lastTreeHeadSize;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return proofs proving that the log tree has been constructed correctly in later entries for each of the given identifiers. Enforced unauthenticated endpoint. 
         * @summary Monitor the given identifiers in the key transparency log
         * @param {KeyTransparencyMonitorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitor(body: KeyTransparencyMonitorRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling monitor.');
            }
            const localVarPath = `/v1/key-transparency/monitor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KeyTransparencyMonitorRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a response if the ACI exists in the transparency log and its mapped value matches the provided ACI identity key.  The username hash search response field is populated if it is found in the log and its mapped value matches the provided ACI. The E164 search response is populated similarly, with some additional requirements: - The account associated with the provided ACI must be discoverable by phone number. - The provided unidentified access key must match the one on the account.  Enforced unauthenticated endpoint. 
         * @summary Search for the given identifiers in the key transparency log
         * @param {KeyTransparencySearchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(body: KeyTransparencySearchRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling search.');
            }
            const localVarPath = `/v1/key-transparency/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KeyTransparencySearchRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeyTransparencyApi - functional programming interface
 * @export
 */
export const KeyTransparencyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * The response contains the distinguished tree head to prove consistency against for future calls to `/search`, `/monitor`, and `/distinguished`. Enforced unauthenticated endpoint. 
         * @summary Get the current value of the distinguished key
         * @param {number} [lastTreeHeadSize] The distinguished tree head size returned by a previously verified call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinguishedKey(lastTreeHeadSize?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyTransparencyDistinguishedKeyResponse> {
            const localVarFetchArgs = KeyTransparencyApiFetchParamCreator(configuration).getDistinguishedKey(lastTreeHeadSize, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return proofs proving that the log tree has been constructed correctly in later entries for each of the given identifiers. Enforced unauthenticated endpoint. 
         * @summary Monitor the given identifiers in the key transparency log
         * @param {KeyTransparencyMonitorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitor(body: KeyTransparencyMonitorRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyTransparencyMonitorResponse> {
            const localVarFetchArgs = KeyTransparencyApiFetchParamCreator(configuration).monitor(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a response if the ACI exists in the transparency log and its mapped value matches the provided ACI identity key.  The username hash search response field is populated if it is found in the log and its mapped value matches the provided ACI. The E164 search response is populated similarly, with some additional requirements: - The account associated with the provided ACI must be discoverable by phone number. - The provided unidentified access key must match the one on the account.  Enforced unauthenticated endpoint. 
         * @summary Search for the given identifiers in the key transparency log
         * @param {KeyTransparencySearchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(body: KeyTransparencySearchRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KeyTransparencySearchResponse> {
            const localVarFetchArgs = KeyTransparencyApiFetchParamCreator(configuration).search(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KeyTransparencyApi - factory interface
 * @export
 */
export const KeyTransparencyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The response contains the distinguished tree head to prove consistency against for future calls to `/search`, `/monitor`, and `/distinguished`. Enforced unauthenticated endpoint. 
         * @summary Get the current value of the distinguished key
         * @param {number} [lastTreeHeadSize] The distinguished tree head size returned by a previously verified call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDistinguishedKey(lastTreeHeadSize?: number, options?: any) {
            return KeyTransparencyApiFp(configuration).getDistinguishedKey(lastTreeHeadSize, options)(fetch, basePath);
        },
        /**
         * Return proofs proving that the log tree has been constructed correctly in later entries for each of the given identifiers. Enforced unauthenticated endpoint. 
         * @summary Monitor the given identifiers in the key transparency log
         * @param {KeyTransparencyMonitorRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        monitor(body: KeyTransparencyMonitorRequest, options?: any) {
            return KeyTransparencyApiFp(configuration).monitor(body, options)(fetch, basePath);
        },
        /**
         * Returns a response if the ACI exists in the transparency log and its mapped value matches the provided ACI identity key.  The username hash search response field is populated if it is found in the log and its mapped value matches the provided ACI. The E164 search response is populated similarly, with some additional requirements: - The account associated with the provided ACI must be discoverable by phone number. - The provided unidentified access key must match the one on the account.  Enforced unauthenticated endpoint. 
         * @summary Search for the given identifiers in the key transparency log
         * @param {KeyTransparencySearchRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(body: KeyTransparencySearchRequest, options?: any) {
            return KeyTransparencyApiFp(configuration).search(body, options)(fetch, basePath);
        },
    };
};

/**
 * KeyTransparencyApi - object-oriented interface
 * @export
 * @class KeyTransparencyApi
 * @extends {BaseAPI}
 */
export class KeyTransparencyApi extends BaseAPI {
    /**
     * The response contains the distinguished tree head to prove consistency against for future calls to `/search`, `/monitor`, and `/distinguished`. Enforced unauthenticated endpoint. 
     * @summary Get the current value of the distinguished key
     * @param {number} [lastTreeHeadSize] The distinguished tree head size returned by a previously verified call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyTransparencyApi
     */
    public getDistinguishedKey(lastTreeHeadSize?: number, options?: any) {
        return KeyTransparencyApiFp(this.configuration).getDistinguishedKey(lastTreeHeadSize, options)(this.fetch, this.basePath);
    }

    /**
     * Return proofs proving that the log tree has been constructed correctly in later entries for each of the given identifiers. Enforced unauthenticated endpoint. 
     * @summary Monitor the given identifiers in the key transparency log
     * @param {KeyTransparencyMonitorRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyTransparencyApi
     */
    public monitor(body: KeyTransparencyMonitorRequest, options?: any) {
        return KeyTransparencyApiFp(this.configuration).monitor(body, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a response if the ACI exists in the transparency log and its mapped value matches the provided ACI identity key.  The username hash search response field is populated if it is found in the log and its mapped value matches the provided ACI. The E164 search response is populated similarly, with some additional requirements: - The account associated with the provided ACI must be discoverable by phone number. - The provided unidentified access key must match the one on the account.  Enforced unauthenticated endpoint. 
     * @summary Search for the given identifiers in the key transparency log
     * @param {KeyTransparencySearchRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeyTransparencyApi
     */
    public search(body: KeyTransparencySearchRequest, options?: any) {
        return KeyTransparencyApiFp(this.configuration).search(body, options)(this.fetch, this.basePath);
    }

}
/**
 * KeysApi - fetch parameter creator
 * @export
 */
export const KeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Checks that client and server have consistent views of repeated-use keys. For a given identity type, clients submit a digest of their repeated-use key material. The digest is calculated as:  SHA256(identityKeyBytes || signedEcPreKeyId || signedEcPreKeyIdBytes || lastResortKeyId || lastResortKeyBytes)  …where the elements of the hash are:  - identityKeyBytes: the serialized form of the client's public identity key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - signedEcPreKeyId: an 8-byte, big-endian representation of the ID of the client's signed EC pre-key - signedEcPreKeyBytes: the serialized form of the client's signed EC pre-key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - lastResortKeyId: an 8-byte, big-endian representation of the ID of the client's last-resort Kyber key - lastResortKeyBytes: the serialized form of the client's last-resort Kyber key as produced by libsignal (i.e. one   version byte followed by 1568 bytes of key material for a total of 1569 bytes) 
         * @summary Check keys
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkKeys(userAgent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/keys/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the public identity key and available device prekeys for a specified account or phone-number identity
         * @summary Fetch public keys for another user
         * @param {ServiceIdentifier} identifier the account or phone-number identifier to retrieve keys for
         * @param {string} deviceId the device id of a single device to retrieve prekeys for, or &#x60;*&#x60; for all enabled devices
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {GroupSendTokenHeader} [groupSendToken] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceKeys(identifier: ServiceIdentifier, deviceId: string, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling getDeviceKeys.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling getDeviceKeys.');
            }
            const localVarPath = `/v2/keys/{identifier}/{device_id}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (unidentifiedAccessKey !== undefined && unidentifiedAccessKey !== null) {
                localVarHeaderParameter['Unidentified-Access-Key'] = String(unidentifiedAccessKey);
            }

            if (groupSendToken !== undefined && groupSendToken !== null) {
                localVarHeaderParameter['Group-Send-Token'] = String(groupSendToken);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the number of one-time prekeys uploaded for this device and still available
         * @summary Get prekey count
         * @param {string} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(identity?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload new pre-keys for this device.
         * @summary Upload new prekeys
         * @param {string} [identity] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setKeys(identity?: string, userAgent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v2/keys`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (identity !== undefined) {
                localVarQueryParameter['identity'] = identity;
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeysApi - functional programming interface
 * @export
 */
export const KeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Checks that client and server have consistent views of repeated-use keys. For a given identity type, clients submit a digest of their repeated-use key material. The digest is calculated as:  SHA256(identityKeyBytes || signedEcPreKeyId || signedEcPreKeyIdBytes || lastResortKeyId || lastResortKeyBytes)  …where the elements of the hash are:  - identityKeyBytes: the serialized form of the client's public identity key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - signedEcPreKeyId: an 8-byte, big-endian representation of the ID of the client's signed EC pre-key - signedEcPreKeyBytes: the serialized form of the client's signed EC pre-key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - lastResortKeyId: an 8-byte, big-endian representation of the ID of the client's last-resort Kyber key - lastResortKeyBytes: the serialized form of the client's last-resort Kyber key as produced by libsignal (i.e. one   version byte followed by 1568 bytes of key material for a total of 1569 bytes) 
         * @summary Check keys
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkKeys(userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeysApiFetchParamCreator(configuration).checkKeys(userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the public identity key and available device prekeys for a specified account or phone-number identity
         * @summary Fetch public keys for another user
         * @param {ServiceIdentifier} identifier the account or phone-number identifier to retrieve keys for
         * @param {string} deviceId the device id of a single device to retrieve prekeys for, or &#x60;*&#x60; for all enabled devices
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {GroupSendTokenHeader} [groupSendToken] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceKeys(identifier: ServiceIdentifier, deviceId: string, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PreKeyResponse> {
            const localVarFetchArgs = KeysApiFetchParamCreator(configuration).getDeviceKeys(identifier, deviceId, unidentifiedAccessKey, groupSendToken, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the number of one-time prekeys uploaded for this device and still available
         * @summary Get prekey count
         * @param {string} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(identity?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PreKeyCount> {
            const localVarFetchArgs = KeysApiFetchParamCreator(configuration).getStatus(identity, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upload new pre-keys for this device.
         * @summary Upload new prekeys
         * @param {string} [identity] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setKeys(identity?: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = KeysApiFetchParamCreator(configuration).setKeys(identity, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KeysApi - factory interface
 * @export
 */
export const KeysApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Checks that client and server have consistent views of repeated-use keys. For a given identity type, clients submit a digest of their repeated-use key material. The digest is calculated as:  SHA256(identityKeyBytes || signedEcPreKeyId || signedEcPreKeyIdBytes || lastResortKeyId || lastResortKeyBytes)  …where the elements of the hash are:  - identityKeyBytes: the serialized form of the client's public identity key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - signedEcPreKeyId: an 8-byte, big-endian representation of the ID of the client's signed EC pre-key - signedEcPreKeyBytes: the serialized form of the client's signed EC pre-key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - lastResortKeyId: an 8-byte, big-endian representation of the ID of the client's last-resort Kyber key - lastResortKeyBytes: the serialized form of the client's last-resort Kyber key as produced by libsignal (i.e. one   version byte followed by 1568 bytes of key material for a total of 1569 bytes) 
         * @summary Check keys
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkKeys(userAgent?: string, options?: any) {
            return KeysApiFp(configuration).checkKeys(userAgent, options)(fetch, basePath);
        },
        /**
         * Retrieves the public identity key and available device prekeys for a specified account or phone-number identity
         * @summary Fetch public keys for another user
         * @param {ServiceIdentifier} identifier the account or phone-number identifier to retrieve keys for
         * @param {string} deviceId the device id of a single device to retrieve prekeys for, or &#x60;*&#x60; for all enabled devices
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {GroupSendTokenHeader} [groupSendToken] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceKeys(identifier: ServiceIdentifier, deviceId: string, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, options?: any) {
            return KeysApiFp(configuration).getDeviceKeys(identifier, deviceId, unidentifiedAccessKey, groupSendToken, userAgent, options)(fetch, basePath);
        },
        /**
         * Gets the number of one-time prekeys uploaded for this device and still available
         * @summary Get prekey count
         * @param {string} [identity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(identity?: string, options?: any) {
            return KeysApiFp(configuration).getStatus(identity, options)(fetch, basePath);
        },
        /**
         * Upload new pre-keys for this device.
         * @summary Upload new prekeys
         * @param {string} [identity] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setKeys(identity?: string, userAgent?: string, options?: any) {
            return KeysApiFp(configuration).setKeys(identity, userAgent, options)(fetch, basePath);
        },
    };
};

/**
 * KeysApi - object-oriented interface
 * @export
 * @class KeysApi
 * @extends {BaseAPI}
 */
export class KeysApi extends BaseAPI {
    /**
     * Checks that client and server have consistent views of repeated-use keys. For a given identity type, clients submit a digest of their repeated-use key material. The digest is calculated as:  SHA256(identityKeyBytes || signedEcPreKeyId || signedEcPreKeyIdBytes || lastResortKeyId || lastResortKeyBytes)  …where the elements of the hash are:  - identityKeyBytes: the serialized form of the client's public identity key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - signedEcPreKeyId: an 8-byte, big-endian representation of the ID of the client's signed EC pre-key - signedEcPreKeyBytes: the serialized form of the client's signed EC pre-key as produced by libsignal (i.e. one   version byte followed by 32 bytes of key material for a total of 33 bytes) - lastResortKeyId: an 8-byte, big-endian representation of the ID of the client's last-resort Kyber key - lastResortKeyBytes: the serialized form of the client's last-resort Kyber key as produced by libsignal (i.e. one   version byte followed by 1568 bytes of key material for a total of 1569 bytes) 
     * @summary Check keys
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public checkKeys(userAgent?: string, options?: any) {
        return KeysApiFp(this.configuration).checkKeys(userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the public identity key and available device prekeys for a specified account or phone-number identity
     * @summary Fetch public keys for another user
     * @param {ServiceIdentifier} identifier the account or phone-number identifier to retrieve keys for
     * @param {string} deviceId the device id of a single device to retrieve prekeys for, or &#x60;*&#x60; for all enabled devices
     * @param {Anonymous} [unidentifiedAccessKey] 
     * @param {GroupSendTokenHeader} [groupSendToken] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public getDeviceKeys(identifier: ServiceIdentifier, deviceId: string, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, options?: any) {
        return KeysApiFp(this.configuration).getDeviceKeys(identifier, deviceId, unidentifiedAccessKey, groupSendToken, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the number of one-time prekeys uploaded for this device and still available
     * @summary Get prekey count
     * @param {string} [identity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public getStatus(identity?: string, options?: any) {
        return KeysApiFp(this.configuration).getStatus(identity, options)(this.fetch, this.basePath);
    }

    /**
     * Upload new pre-keys for this device.
     * @summary Upload new prekeys
     * @param {string} [identity] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public setKeys(identity?: string, userAgent?: string, options?: any) {
        return KeysApiFp(this.configuration).setKeys(identity, userAgent, options)(this.fetch, this.basePath);
    }

}
/**
 * MessagesApi - fetch parameter creator
 * @export
 */
export const MessagesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [xSignalReceiveStories] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingMessages(xSignalReceiveStories?: string, userAgent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/messages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (xSignalReceiveStories !== undefined && xSignalReceiveStories !== null) {
                localVarHeaderParameter['X-Signal-Receive-Stories'] = String(xSignalReceiveStories);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePendingMessage(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling removePendingMessage.');
            }
            const localVarPath = `/v1/messages/uuid/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} source 
         * @param {string} messageGuid 
         * @param {SpamReport} [body] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSpamMessage(source: string, messageGuid: string, body?: SpamReport, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling reportSpamMessage.');
            }
            // verify required parameter 'messageGuid' is not null or undefined
            if (messageGuid === null || messageGuid === undefined) {
                throw new RequiredError('messageGuid','Required parameter messageGuid was null or undefined when calling reportSpamMessage.');
            }
            const localVarPath = `/v1/messages/report/{source}/{messageGuid}`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)))
                .replace(`{${"messageGuid"}}`, encodeURIComponent(String(messageGuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpamReport" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deliver a message to a single recipient. May be authenticated or unauthenticated; if unauthenticated, an unidentifed-access key or group-send endorsement token must be provided, unless the message is a story. 
         * @summary Send a message
         * @param {IncomingMessageList} body The encrypted message payloads for each recipient device
         * @param {ServiceIdentifier} destination If true, deliver the message only to recipients that are online when it is sent
         * @param {Anonymous} [unidentifiedAccessKey] The recipient&#x27;s unidentified access key
         * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering the recipient. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
         * @param {string} [userAgent] 
         * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(body: IncomingMessageList, destination: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, story?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMessage.');
            }
            // verify required parameter 'destination' is not null or undefined
            if (destination === null || destination === undefined) {
                throw new RequiredError('destination','Required parameter destination was null or undefined when calling sendMessage.');
            }
            const localVarPath = `/v1/messages/{destination}`
                .replace(`{${"destination"}}`, encodeURIComponent(String(destination)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (story !== undefined) {
                localVarQueryParameter['story'] = story;
            }

            if (unidentifiedAccessKey !== undefined && unidentifiedAccessKey !== null) {
                localVarHeaderParameter['Unidentified-Access-Key'] = String(unidentifiedAccessKey);
            }

            if (groupSendToken !== undefined && groupSendToken !== null) {
                localVarHeaderParameter['Group-Send-Token'] = String(groupSendToken);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IncomingMessageList" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deliver a common-payload message to multiple recipients. An unidentifed-access key for all recipients must be provided, unless the message is a story. 
         * @summary Send multi-recipient sealed-sender message
         * @param {SealedSenderMultiRecipientMessage} body The sealed-sender multi-recipient message payload as serialized by libsignal
         * @param {CombinedUnidentifiedSenderAccessKeys} [unidentifiedAccessKey] The bitwise xor of the unidentified access keys for every recipient of the message. Will be replaced with group send endorsements
         * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering recipients of this message. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
         * @param {string} [userAgent] 
         * @param {boolean} [online] If true, deliver the message only to recipients that are online when it is sent
         * @param {number} [ts] The sender&#x27;s timestamp for the envelope
         * @param {boolean} [urgent] If true, this message should cause push notifications to be sent to recipients
         * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMultiRecipientMessage(body: SealedSenderMultiRecipientMessage, unidentifiedAccessKey?: CombinedUnidentifiedSenderAccessKeys, groupSendToken?: GroupSendTokenHeader, userAgent?: string, online?: boolean, ts?: number, urgent?: boolean, story?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMultiRecipientMessage.');
            }
            const localVarPath = `/v1/messages/multi_recipient`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (online !== undefined) {
                localVarQueryParameter['online'] = online;
            }

            if (ts !== undefined) {
                localVarQueryParameter['ts'] = ts;
            }

            if (urgent !== undefined) {
                localVarQueryParameter['urgent'] = urgent;
            }

            if (story !== undefined) {
                localVarQueryParameter['story'] = story;
            }

            if (unidentifiedAccessKey !== undefined && unidentifiedAccessKey !== null) {
                localVarHeaderParameter['Unidentified-Access-Key'] = String(unidentifiedAccessKey);
            }

            if (groupSendToken !== undefined && groupSendToken !== null) {
                localVarHeaderParameter['Group-Send-Token'] = String(groupSendToken);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/vnd.signal-messenger.mrm';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SealedSenderMultiRecipientMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [xSignalReceiveStories] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingMessages(xSignalReceiveStories?: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).getPendingMessages(xSignalReceiveStories, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePendingMessage(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).removePendingMessage(uuid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} source 
         * @param {string} messageGuid 
         * @param {SpamReport} [body] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSpamMessage(source: string, messageGuid: string, body?: SpamReport, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).reportSpamMessage(source, messageGuid, body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deliver a message to a single recipient. May be authenticated or unauthenticated; if unauthenticated, an unidentifed-access key or group-send endorsement token must be provided, unless the message is a story. 
         * @summary Send a message
         * @param {IncomingMessageList} body The encrypted message payloads for each recipient device
         * @param {ServiceIdentifier} destination If true, deliver the message only to recipients that are online when it is sent
         * @param {Anonymous} [unidentifiedAccessKey] The recipient&#x27;s unidentified access key
         * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering the recipient. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
         * @param {string} [userAgent] 
         * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(body: IncomingMessageList, destination: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, story?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).sendMessage(body, destination, unidentifiedAccessKey, groupSendToken, userAgent, story, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deliver a common-payload message to multiple recipients. An unidentifed-access key for all recipients must be provided, unless the message is a story. 
         * @summary Send multi-recipient sealed-sender message
         * @param {SealedSenderMultiRecipientMessage} body The sealed-sender multi-recipient message payload as serialized by libsignal
         * @param {CombinedUnidentifiedSenderAccessKeys} [unidentifiedAccessKey] The bitwise xor of the unidentified access keys for every recipient of the message. Will be replaced with group send endorsements
         * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering recipients of this message. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
         * @param {string} [userAgent] 
         * @param {boolean} [online] If true, deliver the message only to recipients that are online when it is sent
         * @param {number} [ts] The sender&#x27;s timestamp for the envelope
         * @param {boolean} [urgent] If true, this message should cause push notifications to be sent to recipients
         * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMultiRecipientMessage(body: SealedSenderMultiRecipientMessage, unidentifiedAccessKey?: CombinedUnidentifiedSenderAccessKeys, groupSendToken?: GroupSendTokenHeader, userAgent?: string, online?: boolean, ts?: number, urgent?: boolean, story?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SendMultiRecipientMessageResponse> {
            const localVarFetchArgs = MessagesApiFetchParamCreator(configuration).sendMultiRecipientMessage(body, unidentifiedAccessKey, groupSendToken, userAgent, online, ts, urgent, story, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [xSignalReceiveStories] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingMessages(xSignalReceiveStories?: string, userAgent?: string, options?: any) {
            return MessagesApiFp(configuration).getPendingMessages(xSignalReceiveStories, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePendingMessage(uuid: string, options?: any) {
            return MessagesApiFp(configuration).removePendingMessage(uuid, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} source 
         * @param {string} messageGuid 
         * @param {SpamReport} [body] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSpamMessage(source: string, messageGuid: string, body?: SpamReport, userAgent?: string, options?: any) {
            return MessagesApiFp(configuration).reportSpamMessage(source, messageGuid, body, userAgent, options)(fetch, basePath);
        },
        /**
         * Deliver a message to a single recipient. May be authenticated or unauthenticated; if unauthenticated, an unidentifed-access key or group-send endorsement token must be provided, unless the message is a story. 
         * @summary Send a message
         * @param {IncomingMessageList} body The encrypted message payloads for each recipient device
         * @param {ServiceIdentifier} destination If true, deliver the message only to recipients that are online when it is sent
         * @param {Anonymous} [unidentifiedAccessKey] The recipient&#x27;s unidentified access key
         * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering the recipient. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
         * @param {string} [userAgent] 
         * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(body: IncomingMessageList, destination: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, story?: boolean, options?: any) {
            return MessagesApiFp(configuration).sendMessage(body, destination, unidentifiedAccessKey, groupSendToken, userAgent, story, options)(fetch, basePath);
        },
        /**
         * Deliver a common-payload message to multiple recipients. An unidentifed-access key for all recipients must be provided, unless the message is a story. 
         * @summary Send multi-recipient sealed-sender message
         * @param {SealedSenderMultiRecipientMessage} body The sealed-sender multi-recipient message payload as serialized by libsignal
         * @param {CombinedUnidentifiedSenderAccessKeys} [unidentifiedAccessKey] The bitwise xor of the unidentified access keys for every recipient of the message. Will be replaced with group send endorsements
         * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering recipients of this message. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
         * @param {string} [userAgent] 
         * @param {boolean} [online] If true, deliver the message only to recipients that are online when it is sent
         * @param {number} [ts] The sender&#x27;s timestamp for the envelope
         * @param {boolean} [urgent] If true, this message should cause push notifications to be sent to recipients
         * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMultiRecipientMessage(body: SealedSenderMultiRecipientMessage, unidentifiedAccessKey?: CombinedUnidentifiedSenderAccessKeys, groupSendToken?: GroupSendTokenHeader, userAgent?: string, online?: boolean, ts?: number, urgent?: boolean, story?: boolean, options?: any) {
            return MessagesApiFp(configuration).sendMultiRecipientMessage(body, unidentifiedAccessKey, groupSendToken, userAgent, online, ts, urgent, story, options)(fetch, basePath);
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * 
     * @param {string} [xSignalReceiveStories] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getPendingMessages(xSignalReceiveStories?: string, userAgent?: string, options?: any) {
        return MessagesApiFp(this.configuration).getPendingMessages(xSignalReceiveStories, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public removePendingMessage(uuid: string, options?: any) {
        return MessagesApiFp(this.configuration).removePendingMessage(uuid, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} source 
     * @param {string} messageGuid 
     * @param {SpamReport} [body] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public reportSpamMessage(source: string, messageGuid: string, body?: SpamReport, userAgent?: string, options?: any) {
        return MessagesApiFp(this.configuration).reportSpamMessage(source, messageGuid, body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Deliver a message to a single recipient. May be authenticated or unauthenticated; if unauthenticated, an unidentifed-access key or group-send endorsement token must be provided, unless the message is a story. 
     * @summary Send a message
     * @param {IncomingMessageList} body The encrypted message payloads for each recipient device
     * @param {ServiceIdentifier} destination If true, deliver the message only to recipients that are online when it is sent
     * @param {Anonymous} [unidentifiedAccessKey] The recipient&#x27;s unidentified access key
     * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering the recipient. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
     * @param {string} [userAgent] 
     * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public sendMessage(body: IncomingMessageList, destination: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, story?: boolean, options?: any) {
        return MessagesApiFp(this.configuration).sendMessage(body, destination, unidentifiedAccessKey, groupSendToken, userAgent, story, options)(this.fetch, this.basePath);
    }

    /**
     * Deliver a common-payload message to multiple recipients. An unidentifed-access key for all recipients must be provided, unless the message is a story. 
     * @summary Send multi-recipient sealed-sender message
     * @param {SealedSenderMultiRecipientMessage} body The sealed-sender multi-recipient message payload as serialized by libsignal
     * @param {CombinedUnidentifiedSenderAccessKeys} [unidentifiedAccessKey] The bitwise xor of the unidentified access keys for every recipient of the message. Will be replaced with group send endorsements
     * @param {GroupSendTokenHeader} [groupSendToken] A group send endorsement token covering recipients of this message. Must not be combined with &#x60;Unidentified-Access-Key&#x60; or set on a story message.
     * @param {string} [userAgent] 
     * @param {boolean} [online] If true, deliver the message only to recipients that are online when it is sent
     * @param {number} [ts] The sender&#x27;s timestamp for the envelope
     * @param {boolean} [urgent] If true, this message should cause push notifications to be sent to recipients
     * @param {boolean} [story] If true, the message is a story; access tokens are not checked and sending to nonexistent recipients is permitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public sendMultiRecipientMessage(body: SealedSenderMultiRecipientMessage, unidentifiedAccessKey?: CombinedUnidentifiedSenderAccessKeys, groupSendToken?: GroupSendTokenHeader, userAgent?: string, online?: boolean, ts?: number, urgent?: boolean, story?: boolean, options?: any) {
        return MessagesApiFp(this.configuration).sendMultiRecipientMessage(body, unidentifiedAccessKey, groupSendToken, userAgent, online, ts, urgent, story, options)(this.fetch, this.basePath);
    }

}
/**
 * OneTimeDonationsApi - fetch parameter creator
 * @export
 */
export const OneTimeDonationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmPayPalBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayPalBoost(body: ConfirmPayPalBoostRequest, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling confirmPayPalBoost.');
            }
            const localVarPath = `/v1/subscription/boost/paypal/confirm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConfirmPayPalBoostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Stripe PaymentIntent and return a client secret that can be used to complete the payment.  Once the payment is complete, the paymentIntentId can be used at /v1/subscriptions/receipt_credentials 
         * @summary Create a Stripe payment intent
         * @param {CreateBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBoostPaymentIntent(body: CreateBoostRequest, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBoostPaymentIntent.');
            }
            const localVarPath = `/v1/subscription/boost/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateBoostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateBoostReceiptCredentialsRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBoostReceiptCredentials(body: CreateBoostReceiptCredentialsRequest, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createBoostReceiptCredentials.');
            }
            const localVarPath = `/v1/subscription/boost/receipt_credentials`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateBoostReceiptCredentialsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePayPalBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayPalBoost(body: CreatePayPalBoostRequest, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPayPalBoost.');
            }
            const localVarPath = `/v1/subscription/boost/paypal/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePayPalBoostRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OneTimeDonationsApi - functional programming interface
 * @export
 */
export const OneTimeDonationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmPayPalBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayPalBoost(body: ConfirmPayPalBoostRequest, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = OneTimeDonationsApiFetchParamCreator(configuration).confirmPayPalBoost(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a Stripe PaymentIntent and return a client secret that can be used to complete the payment.  Once the payment is complete, the paymentIntentId can be used at /v1/subscriptions/receipt_credentials 
         * @summary Create a Stripe payment intent
         * @param {CreateBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBoostPaymentIntent(body: CreateBoostRequest, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateBoostResponse> {
            const localVarFetchArgs = OneTimeDonationsApiFetchParamCreator(configuration).createBoostPaymentIntent(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateBoostReceiptCredentialsRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBoostReceiptCredentials(body: CreateBoostReceiptCredentialsRequest, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = OneTimeDonationsApiFetchParamCreator(configuration).createBoostReceiptCredentials(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreatePayPalBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayPalBoost(body: CreatePayPalBoostRequest, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = OneTimeDonationsApiFetchParamCreator(configuration).createPayPalBoost(body, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OneTimeDonationsApi - factory interface
 * @export
 */
export const OneTimeDonationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ConfirmPayPalBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPayPalBoost(body: ConfirmPayPalBoostRequest, userAgent?: string, options?: any) {
            return OneTimeDonationsApiFp(configuration).confirmPayPalBoost(body, userAgent, options)(fetch, basePath);
        },
        /**
         * Create a Stripe PaymentIntent and return a client secret that can be used to complete the payment.  Once the payment is complete, the paymentIntentId can be used at /v1/subscriptions/receipt_credentials 
         * @summary Create a Stripe payment intent
         * @param {CreateBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBoostPaymentIntent(body: CreateBoostRequest, userAgent?: string, options?: any) {
            return OneTimeDonationsApiFp(configuration).createBoostPaymentIntent(body, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateBoostReceiptCredentialsRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBoostReceiptCredentials(body: CreateBoostReceiptCredentialsRequest, userAgent?: string, options?: any) {
            return OneTimeDonationsApiFp(configuration).createBoostReceiptCredentials(body, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreatePayPalBoostRequest} body 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayPalBoost(body: CreatePayPalBoostRequest, userAgent?: string, options?: any) {
            return OneTimeDonationsApiFp(configuration).createPayPalBoost(body, userAgent, options)(fetch, basePath);
        },
    };
};

/**
 * OneTimeDonationsApi - object-oriented interface
 * @export
 * @class OneTimeDonationsApi
 * @extends {BaseAPI}
 */
export class OneTimeDonationsApi extends BaseAPI {
    /**
     * 
     * @param {ConfirmPayPalBoostRequest} body 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OneTimeDonationsApi
     */
    public confirmPayPalBoost(body: ConfirmPayPalBoostRequest, userAgent?: string, options?: any) {
        return OneTimeDonationsApiFp(this.configuration).confirmPayPalBoost(body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Create a Stripe PaymentIntent and return a client secret that can be used to complete the payment.  Once the payment is complete, the paymentIntentId can be used at /v1/subscriptions/receipt_credentials 
     * @summary Create a Stripe payment intent
     * @param {CreateBoostRequest} body 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OneTimeDonationsApi
     */
    public createBoostPaymentIntent(body: CreateBoostRequest, userAgent?: string, options?: any) {
        return OneTimeDonationsApiFp(this.configuration).createBoostPaymentIntent(body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateBoostReceiptCredentialsRequest} body 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OneTimeDonationsApi
     */
    public createBoostReceiptCredentials(body: CreateBoostReceiptCredentialsRequest, userAgent?: string, options?: any) {
        return OneTimeDonationsApiFp(this.configuration).createBoostReceiptCredentials(body, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreatePayPalBoostRequest} body 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OneTimeDonationsApi
     */
    public createPayPalBoost(body: CreatePayPalBoostRequest, userAgent?: string, options?: any) {
        return OneTimeDonationsApiFp(this.configuration).createPayPalBoost(body, userAgent, options)(this.fetch, this.basePath);
    }

}
/**
 * PaymentsApi - fetch parameter creator
 * @export
 */
export const PaymentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth(options: any = {}): FetchArgs {
            const localVarPath = `/v1/payments/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversions(options: any = {}): FetchArgs {
            const localVarPath = `/v1/payments/conversions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExternalServiceCredentials> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).getAuth(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CurrencyConversionEntityList> {
            const localVarFetchArgs = PaymentsApiFetchParamCreator(configuration).getConversions(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth(options?: any) {
            return PaymentsApiFp(configuration).getAuth(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversions(options?: any) {
            return PaymentsApiFp(configuration).getConversions(options)(fetch, basePath);
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getAuth(options?: any) {
        return PaymentsApiFp(this.configuration).getAuth(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getConversions(options?: any) {
        return PaymentsApiFp(this.configuration).getConversions(options)(this.fetch, this.basePath);
    }

}
/**
 * ProfileApi - fetch parameter creator
 * @export
 */
export const ProfileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AciServiceIdentifier} identifier 
         * @param {string} version 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(identifier: AciServiceIdentifier, version: string, unidentifiedAccessKey?: Anonymous, options: any = {}): FetchArgs {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling getProfile.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getProfile.');
            }
            const localVarPath = `/v1/profile/{identifier}/{version}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (unidentifiedAccessKey !== undefined && unidentifiedAccessKey !== null) {
                localVarHeaderParameter['Unidentified-Access-Key'] = String(unidentifiedAccessKey);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AciServiceIdentifier} identifier 
         * @param {string} version 
         * @param {string} credentialRequest 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {string} [credentialType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile1(identifier: AciServiceIdentifier, version: string, credentialRequest: string, unidentifiedAccessKey?: Anonymous, credentialType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling getProfile1.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getProfile1.');
            }
            // verify required parameter 'credentialRequest' is not null or undefined
            if (credentialRequest === null || credentialRequest === undefined) {
                throw new RequiredError('credentialRequest','Required parameter credentialRequest was null or undefined when calling getProfile1.');
            }
            const localVarPath = `/v1/profile/{identifier}/{version}/{credentialRequest}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)))
                .replace(`{${"credentialRequest"}}`, encodeURIComponent(String(credentialRequest)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (credentialType !== undefined) {
                localVarQueryParameter['credentialType'] = credentialType;
            }

            if (unidentifiedAccessKey !== undefined && unidentifiedAccessKey !== null) {
                localVarHeaderParameter['Unidentified-Access-Key'] = String(unidentifiedAccessKey);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceIdentifier} identifier 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {GroupSendTokenHeader} [groupSendToken] 
         * @param {string} [userAgent] 
         * @param {boolean} [ca] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnversionedProfile(identifier: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, ca?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling getUnversionedProfile.');
            }
            const localVarPath = `/v1/profile/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (ca !== undefined) {
                localVarQueryParameter['ca'] = ca;
            }

            if (unidentifiedAccessKey !== undefined && unidentifiedAccessKey !== null) {
                localVarHeaderParameter['Unidentified-Access-Key'] = String(unidentifiedAccessKey);
            }

            if (groupSendToken !== undefined && groupSendToken !== null) {
                localVarHeaderParameter['Group-Send-Token'] = String(groupSendToken);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BatchIdentityCheckRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runBatchIdentityCheck(body: BatchIdentityCheckRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling runBatchIdentityCheck.');
            }
            const localVarPath = `/v1/profile/identity_check/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BatchIdentityCheckRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateProfileRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfile(body: CreateProfileRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setProfile.');
            }
            const localVarPath = `/v1/profile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateProfileRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AciServiceIdentifier} identifier 
         * @param {string} version 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(identifier: AciServiceIdentifier, version: string, unidentifiedAccessKey?: Anonymous, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VersionedProfileResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getProfile(identifier, version, unidentifiedAccessKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {AciServiceIdentifier} identifier 
         * @param {string} version 
         * @param {string} credentialRequest 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {string} [credentialType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile1(identifier: AciServiceIdentifier, version: string, credentialRequest: string, unidentifiedAccessKey?: Anonymous, credentialType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CredentialProfileResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getProfile1(identifier, version, credentialRequest, unidentifiedAccessKey, credentialType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {ServiceIdentifier} identifier 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {GroupSendTokenHeader} [groupSendToken] 
         * @param {string} [userAgent] 
         * @param {boolean} [ca] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnversionedProfile(identifier: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, ca?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseProfileResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getUnversionedProfile(identifier, unidentifiedAccessKey, groupSendToken, userAgent, ca, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BatchIdentityCheckRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runBatchIdentityCheck(body: BatchIdentityCheckRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchIdentityCheckResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).runBatchIdentityCheck(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateProfileRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfile(body: CreateProfileRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).setProfile(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {AciServiceIdentifier} identifier 
         * @param {string} version 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(identifier: AciServiceIdentifier, version: string, unidentifiedAccessKey?: Anonymous, options?: any) {
            return ProfileApiFp(configuration).getProfile(identifier, version, unidentifiedAccessKey, options)(fetch, basePath);
        },
        /**
         * 
         * @param {AciServiceIdentifier} identifier 
         * @param {string} version 
         * @param {string} credentialRequest 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {string} [credentialType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile1(identifier: AciServiceIdentifier, version: string, credentialRequest: string, unidentifiedAccessKey?: Anonymous, credentialType?: string, options?: any) {
            return ProfileApiFp(configuration).getProfile1(identifier, version, credentialRequest, unidentifiedAccessKey, credentialType, options)(fetch, basePath);
        },
        /**
         * 
         * @param {ServiceIdentifier} identifier 
         * @param {Anonymous} [unidentifiedAccessKey] 
         * @param {GroupSendTokenHeader} [groupSendToken] 
         * @param {string} [userAgent] 
         * @param {boolean} [ca] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnversionedProfile(identifier: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, ca?: boolean, options?: any) {
            return ProfileApiFp(configuration).getUnversionedProfile(identifier, unidentifiedAccessKey, groupSendToken, userAgent, ca, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BatchIdentityCheckRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runBatchIdentityCheck(body: BatchIdentityCheckRequest, options?: any) {
            return ProfileApiFp(configuration).runBatchIdentityCheck(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateProfileRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProfile(body: CreateProfileRequest, options?: any) {
            return ProfileApiFp(configuration).setProfile(body, options)(fetch, basePath);
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * 
     * @param {AciServiceIdentifier} identifier 
     * @param {string} version 
     * @param {Anonymous} [unidentifiedAccessKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile(identifier: AciServiceIdentifier, version: string, unidentifiedAccessKey?: Anonymous, options?: any) {
        return ProfileApiFp(this.configuration).getProfile(identifier, version, unidentifiedAccessKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {AciServiceIdentifier} identifier 
     * @param {string} version 
     * @param {string} credentialRequest 
     * @param {Anonymous} [unidentifiedAccessKey] 
     * @param {string} [credentialType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile1(identifier: AciServiceIdentifier, version: string, credentialRequest: string, unidentifiedAccessKey?: Anonymous, credentialType?: string, options?: any) {
        return ProfileApiFp(this.configuration).getProfile1(identifier, version, credentialRequest, unidentifiedAccessKey, credentialType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {ServiceIdentifier} identifier 
     * @param {Anonymous} [unidentifiedAccessKey] 
     * @param {GroupSendTokenHeader} [groupSendToken] 
     * @param {string} [userAgent] 
     * @param {boolean} [ca] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getUnversionedProfile(identifier: ServiceIdentifier, unidentifiedAccessKey?: Anonymous, groupSendToken?: GroupSendTokenHeader, userAgent?: string, ca?: boolean, options?: any) {
        return ProfileApiFp(this.configuration).getUnversionedProfile(identifier, unidentifiedAccessKey, groupSendToken, userAgent, ca, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BatchIdentityCheckRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public runBatchIdentityCheck(body: BatchIdentityCheckRequest, options?: any) {
        return ProfileApiFp(this.configuration).runBatchIdentityCheck(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateProfileRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public setProfile(body: CreateProfileRequest, options?: any) {
        return ProfileApiFp(this.configuration).setProfile(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProvisioningApi - fetch parameter creator
 * @export
 */
export const ProvisioningApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a provisioning message from an authenticated device to a device that (presumably) is not yet associated with a Signal account. 
         * @summary Send a provisioning message to a new device
         * @param {ProvisioningMessage} body The provisioning message to send to the given provisioning address
         * @param {string} destination The temporary provisioning address to which to send a provisioning message
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendProvisioningMessage(body: ProvisioningMessage, destination: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendProvisioningMessage.');
            }
            // verify required parameter 'destination' is not null or undefined
            if (destination === null || destination === undefined) {
                throw new RequiredError('destination','Required parameter destination was null or undefined when calling sendProvisioningMessage.');
            }
            const localVarPath = `/v1/provisioning/{destination}`
                .replace(`{${"destination"}}`, encodeURIComponent(String(destination)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProvisioningMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvisioningApi - functional programming interface
 * @export
 */
export const ProvisioningApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Send a provisioning message from an authenticated device to a device that (presumably) is not yet associated with a Signal account. 
         * @summary Send a provisioning message to a new device
         * @param {ProvisioningMessage} body The provisioning message to send to the given provisioning address
         * @param {string} destination The temporary provisioning address to which to send a provisioning message
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendProvisioningMessage(body: ProvisioningMessage, destination: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProvisioningApiFetchParamCreator(configuration).sendProvisioningMessage(body, destination, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProvisioningApi - factory interface
 * @export
 */
export const ProvisioningApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Send a provisioning message from an authenticated device to a device that (presumably) is not yet associated with a Signal account. 
         * @summary Send a provisioning message to a new device
         * @param {ProvisioningMessage} body The provisioning message to send to the given provisioning address
         * @param {string} destination The temporary provisioning address to which to send a provisioning message
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendProvisioningMessage(body: ProvisioningMessage, destination: string, userAgent?: string, options?: any) {
            return ProvisioningApiFp(configuration).sendProvisioningMessage(body, destination, userAgent, options)(fetch, basePath);
        },
    };
};

/**
 * ProvisioningApi - object-oriented interface
 * @export
 * @class ProvisioningApi
 * @extends {BaseAPI}
 */
export class ProvisioningApi extends BaseAPI {
    /**
     * Send a provisioning message from an authenticated device to a device that (presumably) is not yet associated with a Signal account. 
     * @summary Send a provisioning message to a new device
     * @param {ProvisioningMessage} body The provisioning message to send to the given provisioning address
     * @param {string} destination The temporary provisioning address to which to send a provisioning message
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public sendProvisioningMessage(body: ProvisioningMessage, destination: string, userAgent?: string, options?: any) {
        return ProvisioningApiFp(this.configuration).sendProvisioningMessage(body, destination, userAgent, options)(this.fetch, this.basePath);
    }

}
/**
 * RegistrationApi - fetch parameter creator
 * @export
 */
export const RegistrationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registers a new account or attempts to “re-register” an existing account. It is expected that a well-behaved client could make up to three consecutive calls to this API: 1. gets 423 from existing registration lock   2. gets 409 from device available for transfer   3. success   
         * @summary Registers an account
         * @param {RegistrationRequest} body 
         * @param {BasicAuthorizationHeader} authorization 
         * @param {string} [xSignalAgent] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: RegistrationRequest, authorization: BasicAuthorizationHeader, xSignalAgent?: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling register.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling register.');
            }
            const localVarPath = `/v1/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xSignalAgent !== undefined && xSignalAgent !== null) {
                localVarHeaderParameter['X-Signal-Agent'] = String(xSignalAgent);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegistrationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistrationApi - functional programming interface
 * @export
 */
export const RegistrationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Registers a new account or attempts to “re-register” an existing account. It is expected that a well-behaved client could make up to three consecutive calls to this API: 1. gets 423 from existing registration lock   2. gets 409 from device available for transfer   3. success   
         * @summary Registers an account
         * @param {RegistrationRequest} body 
         * @param {BasicAuthorizationHeader} authorization 
         * @param {string} [xSignalAgent] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: RegistrationRequest, authorization: BasicAuthorizationHeader, xSignalAgent?: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountIdentityResponse> {
            const localVarFetchArgs = RegistrationApiFetchParamCreator(configuration).register(body, authorization, xSignalAgent, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RegistrationApi - factory interface
 * @export
 */
export const RegistrationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Registers a new account or attempts to “re-register” an existing account. It is expected that a well-behaved client could make up to three consecutive calls to this API: 1. gets 423 from existing registration lock   2. gets 409 from device available for transfer   3. success   
         * @summary Registers an account
         * @param {RegistrationRequest} body 
         * @param {BasicAuthorizationHeader} authorization 
         * @param {string} [xSignalAgent] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: RegistrationRequest, authorization: BasicAuthorizationHeader, xSignalAgent?: string, userAgent?: string, options?: any) {
            return RegistrationApiFp(configuration).register(body, authorization, xSignalAgent, userAgent, options)(fetch, basePath);
        },
    };
};

/**
 * RegistrationApi - object-oriented interface
 * @export
 * @class RegistrationApi
 * @extends {BaseAPI}
 */
export class RegistrationApi extends BaseAPI {
    /**
     * Registers a new account or attempts to “re-register” an existing account. It is expected that a well-behaved client could make up to three consecutive calls to this API: 1. gets 423 from existing registration lock   2. gets 409 from device available for transfer   3. success   
     * @summary Registers an account
     * @param {RegistrationRequest} body 
     * @param {BasicAuthorizationHeader} authorization 
     * @param {string} [xSignalAgent] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistrationApi
     */
    public register(body: RegistrationRequest, authorization: BasicAuthorizationHeader, xSignalAgent?: string, userAgent?: string, options?: any) {
        return RegistrationApiFp(this.configuration).register(body, authorization, xSignalAgent, userAgent, options)(this.fetch, this.basePath);
    }

}
/**
 * RemoteConfigApi - fetch parameter creator
 * @export
 */
export const RemoteConfigApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remote configuration is a list of namespaced keys that clients may use for consistent configuration or behavior.  Configuration values change over time, and the list should be refreshed periodically, typically at client launch and every few hours thereafter. 
         * @summary Fetch remote configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options: any = {}): FetchArgs {
            const localVarPath = `/v1/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteConfigApi - functional programming interface
 * @export
 */
export const RemoteConfigApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remote configuration is a list of namespaced keys that clients may use for consistent configuration or behavior.  Configuration values change over time, and the list should be refreshed periodically, typically at client launch and every few hours thereafter. 
         * @summary Fetch remote configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRemoteConfigList> {
            const localVarFetchArgs = RemoteConfigApiFetchParamCreator(configuration).getAll(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RemoteConfigApi - factory interface
 * @export
 */
export const RemoteConfigApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Remote configuration is a list of namespaced keys that clients may use for consistent configuration or behavior.  Configuration values change over time, and the list should be refreshed periodically, typically at client launch and every few hours thereafter. 
         * @summary Fetch remote configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any) {
            return RemoteConfigApiFp(configuration).getAll(options)(fetch, basePath);
        },
    };
};

/**
 * RemoteConfigApi - object-oriented interface
 * @export
 * @class RemoteConfigApi
 * @extends {BaseAPI}
 */
export class RemoteConfigApi extends BaseAPI {
    /**
     * Remote configuration is a list of namespaced keys that clients may use for consistent configuration or behavior.  Configuration values change over time, and the list should be refreshed periodically, typically at client launch and every few hours thereafter. 
     * @summary Fetch remote configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteConfigApi
     */
    public getAll(options?: any) {
        return RemoteConfigApiFp(this.configuration).getAll(options)(this.fetch, this.basePath);
    }

}
/**
 * SecureStorageApi - fetch parameter creator
 * @export
 */
export const SecureStorageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate Storage Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
         * @summary Generate credentials for Storage Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth1(options: any = {}): FetchArgs {
            const localVarPath = `/v1/storage/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecureStorageApi - functional programming interface
 * @export
 */
export const SecureStorageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generate Storage Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
         * @summary Generate credentials for Storage Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExternalServiceCredentials> {
            const localVarFetchArgs = SecureStorageApiFetchParamCreator(configuration).getAuth1(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecureStorageApi - factory interface
 * @export
 */
export const SecureStorageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Generate Storage Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
         * @summary Generate credentials for Storage Service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth1(options?: any) {
            return SecureStorageApiFp(configuration).getAuth1(options)(fetch, basePath);
        },
    };
};

/**
 * SecureStorageApi - object-oriented interface
 * @export
 * @class SecureStorageApi
 * @extends {BaseAPI}
 */
export class SecureStorageApi extends BaseAPI {
    /**
     * Generate Storage Service credentials. Generated credentials have an expiration time of 24 hours  (however, the TTL is fully controlled by the server and may change even for already generated credentials). 
     * @summary Generate credentials for Storage Service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecureStorageApi
     */
    public getAuth1(options?: any) {
        return SecureStorageApiFp(this.configuration).getAuth1(options)(this.fetch, this.basePath);
    }

}
/**
 * SecureValueRecoveryApi - fetch parameter creator
 * @export
 */
export const SecureValueRecoveryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Over time, clients may wind up with multiple sets of SVR2 authentication credentials in cloud storage. To determine which set is most current and should be used to communicate with SVR2 to retrieve a master key (from which a registration recovery password can be derived), clients should call this endpoint with a list of stored credentials. The response will identify which (if any) set of credentials are appropriate for communicating with SVR2. 
         * @summary Check SVR2 credentials
         * @param {AuthCheckRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheck(body: AuthCheckRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authCheck.');
            }
            const localVarPath = `/v2/backup/auth/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthCheckRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate SVR2 service credentials. Generated credentials have an expiration time of 30 days (however, the TTL is fully controlled by the server side and may change even for already generated credentials). 
         * @summary Generate credentials for SVR2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth2(options: any = {}): FetchArgs {
            const localVarPath = `/v2/backup/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecureValueRecoveryApi - functional programming interface
 * @export
 */
export const SecureValueRecoveryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Over time, clients may wind up with multiple sets of SVR2 authentication credentials in cloud storage. To determine which set is most current and should be used to communicate with SVR2 to retrieve a master key (from which a registration recovery password can be derived), clients should call this endpoint with a list of stored credentials. The response will identify which (if any) set of credentials are appropriate for communicating with SVR2. 
         * @summary Check SVR2 credentials
         * @param {AuthCheckRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheck(body: AuthCheckRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthCheckResponseV2> {
            const localVarFetchArgs = SecureValueRecoveryApiFetchParamCreator(configuration).authCheck(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate SVR2 service credentials. Generated credentials have an expiration time of 30 days (however, the TTL is fully controlled by the server side and may change even for already generated credentials). 
         * @summary Generate credentials for SVR2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExternalServiceCredentials> {
            const localVarFetchArgs = SecureValueRecoveryApiFetchParamCreator(configuration).getAuth2(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SecureValueRecoveryApi - factory interface
 * @export
 */
export const SecureValueRecoveryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Over time, clients may wind up with multiple sets of SVR2 authentication credentials in cloud storage. To determine which set is most current and should be used to communicate with SVR2 to retrieve a master key (from which a registration recovery password can be derived), clients should call this endpoint with a list of stored credentials. The response will identify which (if any) set of credentials are appropriate for communicating with SVR2. 
         * @summary Check SVR2 credentials
         * @param {AuthCheckRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheck(body: AuthCheckRequest, options?: any) {
            return SecureValueRecoveryApiFp(configuration).authCheck(body, options)(fetch, basePath);
        },
        /**
         * Generate SVR2 service credentials. Generated credentials have an expiration time of 30 days (however, the TTL is fully controlled by the server side and may change even for already generated credentials). 
         * @summary Generate credentials for SVR2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuth2(options?: any) {
            return SecureValueRecoveryApiFp(configuration).getAuth2(options)(fetch, basePath);
        },
    };
};

/**
 * SecureValueRecoveryApi - object-oriented interface
 * @export
 * @class SecureValueRecoveryApi
 * @extends {BaseAPI}
 */
export class SecureValueRecoveryApi extends BaseAPI {
    /**
     * Over time, clients may wind up with multiple sets of SVR2 authentication credentials in cloud storage. To determine which set is most current and should be used to communicate with SVR2 to retrieve a master key (from which a registration recovery password can be derived), clients should call this endpoint with a list of stored credentials. The response will identify which (if any) set of credentials are appropriate for communicating with SVR2. 
     * @summary Check SVR2 credentials
     * @param {AuthCheckRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecureValueRecoveryApi
     */
    public authCheck(body: AuthCheckRequest, options?: any) {
        return SecureValueRecoveryApiFp(this.configuration).authCheck(body, options)(this.fetch, this.basePath);
    }

    /**
     * Generate SVR2 service credentials. Generated credentials have an expiration time of 30 days (however, the TTL is fully controlled by the server side and may change even for already generated credentials). 
     * @summary Generate credentials for SVR2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecureValueRecoveryApi
     */
    public getAuth2(options?: any) {
        return SecureValueRecoveryApiFp(this.configuration).getAuth2(options)(this.fetch, this.basePath);
    }

}
/**
 * StickersApi - fetch parameter creator
 * @export
 */
export const StickersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} count 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickersForm(count: number, options: any = {}): FetchArgs {
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError('count','Required parameter count was null or undefined when calling getStickersForm.');
            }
            const localVarPath = `/v1/sticker/pack/form/{count}`
                .replace(`{${"count"}}`, encodeURIComponent(String(count)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StickersApi - functional programming interface
 * @export
 */
export const StickersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} count 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickersForm(count: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StickerPackFormUploadAttributes> {
            const localVarFetchArgs = StickersApiFetchParamCreator(configuration).getStickersForm(count, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StickersApi - factory interface
 * @export
 */
export const StickersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {number} count 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStickersForm(count: number, options?: any) {
            return StickersApiFp(configuration).getStickersForm(count, options)(fetch, basePath);
        },
    };
};

/**
 * StickersApi - object-oriented interface
 * @export
 * @class StickersApi
 * @extends {BaseAPI}
 */
export class StickersApi extends BaseAPI {
    /**
     * 
     * @param {number} count 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StickersApi
     */
    public getStickersForm(count: number, options?: any) {
        return StickersApiFp(this.configuration).getStickersForm(count, options)(this.fetch, this.basePath);
    }

}
/**
 * SubscriptionsApi - fetch parameter creator
 * @export
 */
export const SubscriptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePayPalBillingAgreementRequest} body 
         * @param {string} subscriberId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayPalPaymentMethod(body: CreatePayPalBillingAgreementRequest, subscriberId: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPayPalPaymentMethod.');
            }
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling createPayPalPaymentMethod.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/create_payment_method/paypal`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePayPalBillingAgreementRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} [type] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(subscriberId: string, type?: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling createPaymentMethod.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/create_payment_method`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetReceiptCredentialsRequest} body 
         * @param {string} subscriberId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionReceiptCredentials(body: GetReceiptCredentialsRequest, subscriberId: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSubscriptionReceiptCredentials.');
            }
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling createSubscriptionReceiptCredentials.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/receipt_credentials`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetReceiptCredentialsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriber(subscriberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling deleteSubscriber.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} bankTransferType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankMandate(bankTransferType: string, options: any = {}): FetchArgs {
            // verify required parameter 'bankTransferType' is not null or undefined
            if (bankTransferType === null || bankTransferType === undefined) {
                throw new RequiredError('bankTransferType','Required parameter bankTransferType was null or undefined when calling getBankMandate.');
            }
            const localVarPath = `/v1/subscription/bank_mandate/{bankTransferType}`
                .replace(`{${"bankTransferType"}}`, encodeURIComponent(String(bankTransferType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all configuration for badges, donation subscriptions, backup subscriptions, and one-time donation ( \"boost\" and \"gift\") minimum and suggested amounts.
         * @summary Subscription configuration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options: any = {}): FetchArgs {
            const localVarPath = `/v1/subscription/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the current subscription associated with the provided subscriberId if one exists.  Although it uses [Stripe’s values](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses), the status field in the response is generic, with [Braintree-specific values](https://developer.paypal.com/braintree/docs/guides/recurring-billing/overview#subscription-statuses) mapped to Stripe's. Since we don’t support trials or unpaid subscriptions, the associated statuses will never be returned by the API. 
         * @summary Subscription information
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionInformation(subscriberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling getSubscriptionInformation.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set an originalTransactionId that represents an IAP subscription made with the app store.  To set up an app store subscription: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.apple.com/documentation/storekit/in-app_purchase/) with the App Store    directly via StoreKit and obtain a originalTransactionId. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement 
         * @summary Set app store subscription
         * @param {string} subscriberId 
         * @param {string} originalTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppStoreSubscription(subscriberId: string, originalTransactionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling setAppStoreSubscription.');
            }
            // verify required parameter 'originalTransactionId' is not null or undefined
            if (originalTransactionId === null || originalTransactionId === undefined) {
                throw new RequiredError('originalTransactionId','Required parameter originalTransactionId was null or undefined when calling setAppStoreSubscription.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/appstore/{originalTransactionId}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)))
                .replace(`{${"originalTransactionId"}}`, encodeURIComponent(String(originalTransactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} setupIntentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodForIdeal(subscriberId: string, setupIntentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling setDefaultPaymentMethodForIdeal.');
            }
            // verify required parameter 'setupIntentId' is not null or undefined
            if (setupIntentId === null || setupIntentId === undefined) {
                throw new RequiredError('setupIntentId','Required parameter setupIntentId was null or undefined when calling setDefaultPaymentMethodForIdeal.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/default_payment_method_for_ideal/{setupIntentId}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)))
                .replace(`{${"setupIntentId"}}`, encodeURIComponent(String(setupIntentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} processor 
         * @param {string} paymentMethodToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodWithProcessor(subscriberId: string, processor: string, paymentMethodToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling setDefaultPaymentMethodWithProcessor.');
            }
            // verify required parameter 'processor' is not null or undefined
            if (processor === null || processor === undefined) {
                throw new RequiredError('processor','Required parameter processor was null or undefined when calling setDefaultPaymentMethodWithProcessor.');
            }
            // verify required parameter 'paymentMethodToken' is not null or undefined
            if (paymentMethodToken === null || paymentMethodToken === undefined) {
                throw new RequiredError('paymentMethodToken','Required parameter paymentMethodToken was null or undefined when calling setDefaultPaymentMethodWithProcessor.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/default_payment_method/{processor}/{paymentMethodToken}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)))
                .replace(`{${"processor"}}`, encodeURIComponent(String(processor)))
                .replace(`{${"paymentMethodToken"}}`, encodeURIComponent(String(paymentMethodToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a purchaseToken that represents an IAP subscription made with Google Play Billing.  To set up a subscription with Google Play Billing: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.android.com/google/play/billing/integrate) with Google Play Billing    directly and obtain a purchaseToken. Do not [acknowledge](https://developer.android.com/google/play/billing/integrate#subscriptions)    the purchaseToken. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement  After calling this method, the payment is confirmed. Callers must durably store their subscriberId before calling this method to ensure their payment is tracked.  Once a purchaseToken to is posted to a subscriberId, the same subscriberId must not be used with another payment method. A different playbilling purchaseToken can be posted to the same subscriberId, in this case the subscription associated with the old purchaseToken will be cancelled. 
         * @summary Set a google play billing purchase token
         * @param {string} subscriberId 
         * @param {string} purchaseToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPlayStoreSubscription(subscriberId: string, purchaseToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling setPlayStoreSubscription.');
            }
            // verify required parameter 'purchaseToken' is not null or undefined
            if (purchaseToken === null || purchaseToken === undefined) {
                throw new RequiredError('purchaseToken','Required parameter purchaseToken was null or undefined when calling setPlayStoreSubscription.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/playbilling/{purchaseToken}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)))
                .replace(`{${"purchaseToken"}}`, encodeURIComponent(String(purchaseToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {number} level 
         * @param {string} currency 
         * @param {string} idempotencyKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevel(subscriberId: string, level: number, currency: string, idempotencyKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling setSubscriptionLevel.');
            }
            // verify required parameter 'level' is not null or undefined
            if (level === null || level === undefined) {
                throw new RequiredError('level','Required parameter level was null or undefined when calling setSubscriptionLevel.');
            }
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling setSubscriptionLevel.');
            }
            // verify required parameter 'idempotencyKey' is not null or undefined
            if (idempotencyKey === null || idempotencyKey === undefined) {
                throw new RequiredError('idempotencyKey','Required parameter idempotencyKey was null or undefined when calling setSubscriptionLevel.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}/level/{level}/{currency}/{idempotencyKey}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)))
                .replace(`{${"level"}}`, encodeURIComponent(String(level)))
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)))
                .replace(`{${"idempotencyKey"}}`, encodeURIComponent(String(idempotencyKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriber(subscriberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'subscriberId' is not null or undefined
            if (subscriberId === null || subscriberId === undefined) {
                throw new RequiredError('subscriberId','Required parameter subscriberId was null or undefined when calling updateSubscriber.');
            }
            const localVarPath = `/v1/subscription/{subscriberId}`
                .replace(`{${"subscriberId"}}`, encodeURIComponent(String(subscriberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authenticatedAccount required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreatePayPalBillingAgreementRequest} body 
         * @param {string} subscriberId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayPalPaymentMethod(body: CreatePayPalBillingAgreementRequest, subscriberId: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).createPayPalPaymentMethod(body, subscriberId, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} [type] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(subscriberId: string, type?: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).createPaymentMethod(subscriberId, type, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {GetReceiptCredentialsRequest} body 
         * @param {string} subscriberId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionReceiptCredentials(body: GetReceiptCredentialsRequest, subscriberId: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).createSubscriptionReceiptCredentials(body, subscriberId, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriber(subscriberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).deleteSubscriber(subscriberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} bankTransferType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankMandate(bankTransferType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getBankMandate(bankTransferType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns all configuration for badges, donation subscriptions, backup subscriptions, and one-time donation ( \"boost\" and \"gift\") minimum and suggested amounts.
         * @summary Subscription configuration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubscriptionConfigurationResponse> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getConfiguration(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns information about the current subscription associated with the provided subscriberId if one exists.  Although it uses [Stripe’s values](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses), the status field in the response is generic, with [Braintree-specific values](https://developer.paypal.com/braintree/docs/guides/recurring-billing/overview#subscription-statuses) mapped to Stripe's. Since we don’t support trials or unpaid subscriptions, the associated statuses will never be returned by the API. 
         * @summary Subscription information
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionInformation(subscriberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubscriptionInformationResponse> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).getSubscriptionInformation(subscriberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set an originalTransactionId that represents an IAP subscription made with the app store.  To set up an app store subscription: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.apple.com/documentation/storekit/in-app_purchase/) with the App Store    directly via StoreKit and obtain a originalTransactionId. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement 
         * @summary Set app store subscription
         * @param {string} subscriberId 
         * @param {string} originalTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppStoreSubscription(subscriberId: string, originalTransactionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).setAppStoreSubscription(subscriberId, originalTransactionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} setupIntentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodForIdeal(subscriberId: string, setupIntentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).setDefaultPaymentMethodForIdeal(subscriberId, setupIntentId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} processor 
         * @param {string} paymentMethodToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodWithProcessor(subscriberId: string, processor: string, paymentMethodToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).setDefaultPaymentMethodWithProcessor(subscriberId, processor, paymentMethodToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set a purchaseToken that represents an IAP subscription made with Google Play Billing.  To set up a subscription with Google Play Billing: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.android.com/google/play/billing/integrate) with Google Play Billing    directly and obtain a purchaseToken. Do not [acknowledge](https://developer.android.com/google/play/billing/integrate#subscriptions)    the purchaseToken. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement  After calling this method, the payment is confirmed. Callers must durably store their subscriberId before calling this method to ensure their payment is tracked.  Once a purchaseToken to is posted to a subscriberId, the same subscriberId must not be used with another payment method. A different playbilling purchaseToken can be posted to the same subscriberId, in this case the subscription associated with the old purchaseToken will be cancelled. 
         * @summary Set a google play billing purchase token
         * @param {string} subscriberId 
         * @param {string} purchaseToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPlayStoreSubscription(subscriberId: string, purchaseToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).setPlayStoreSubscription(subscriberId, purchaseToken, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {number} level 
         * @param {string} currency 
         * @param {string} idempotencyKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevel(subscriberId: string, level: number, currency: string, idempotencyKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponseDefault> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).setSubscriptionLevel(subscriberId, level, currency, idempotencyKey, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriber(subscriberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubscriptionsApiFetchParamCreator(configuration).updateSubscriber(subscriberId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {CreatePayPalBillingAgreementRequest} body 
         * @param {string} subscriberId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayPalPaymentMethod(body: CreatePayPalBillingAgreementRequest, subscriberId: string, userAgent?: string, options?: any) {
            return SubscriptionsApiFp(configuration).createPayPalPaymentMethod(body, subscriberId, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} [type] 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(subscriberId: string, type?: string, userAgent?: string, options?: any) {
            return SubscriptionsApiFp(configuration).createPaymentMethod(subscriberId, type, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {GetReceiptCredentialsRequest} body 
         * @param {string} subscriberId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionReceiptCredentials(body: GetReceiptCredentialsRequest, subscriberId: string, userAgent?: string, options?: any) {
            return SubscriptionsApiFp(configuration).createSubscriptionReceiptCredentials(body, subscriberId, userAgent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriber(subscriberId: string, options?: any) {
            return SubscriptionsApiFp(configuration).deleteSubscriber(subscriberId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} bankTransferType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankMandate(bankTransferType: string, options?: any) {
            return SubscriptionsApiFp(configuration).getBankMandate(bankTransferType, options)(fetch, basePath);
        },
        /**
         * Returns all configuration for badges, donation subscriptions, backup subscriptions, and one-time donation ( \"boost\" and \"gift\") minimum and suggested amounts.
         * @summary Subscription configuration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options?: any) {
            return SubscriptionsApiFp(configuration).getConfiguration(options)(fetch, basePath);
        },
        /**
         * Returns information about the current subscription associated with the provided subscriberId if one exists.  Although it uses [Stripe’s values](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses), the status field in the response is generic, with [Braintree-specific values](https://developer.paypal.com/braintree/docs/guides/recurring-billing/overview#subscription-statuses) mapped to Stripe's. Since we don’t support trials or unpaid subscriptions, the associated statuses will never be returned by the API. 
         * @summary Subscription information
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionInformation(subscriberId: string, options?: any) {
            return SubscriptionsApiFp(configuration).getSubscriptionInformation(subscriberId, options)(fetch, basePath);
        },
        /**
         * Set an originalTransactionId that represents an IAP subscription made with the app store.  To set up an app store subscription: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.apple.com/documentation/storekit/in-app_purchase/) with the App Store    directly via StoreKit and obtain a originalTransactionId. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement 
         * @summary Set app store subscription
         * @param {string} subscriberId 
         * @param {string} originalTransactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAppStoreSubscription(subscriberId: string, originalTransactionId: string, options?: any) {
            return SubscriptionsApiFp(configuration).setAppStoreSubscription(subscriberId, originalTransactionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} setupIntentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodForIdeal(subscriberId: string, setupIntentId: string, options?: any) {
            return SubscriptionsApiFp(configuration).setDefaultPaymentMethodForIdeal(subscriberId, setupIntentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {string} processor 
         * @param {string} paymentMethodToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethodWithProcessor(subscriberId: string, processor: string, paymentMethodToken: string, options?: any) {
            return SubscriptionsApiFp(configuration).setDefaultPaymentMethodWithProcessor(subscriberId, processor, paymentMethodToken, options)(fetch, basePath);
        },
        /**
         * Set a purchaseToken that represents an IAP subscription made with Google Play Billing.  To set up a subscription with Google Play Billing: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.android.com/google/play/billing/integrate) with Google Play Billing    directly and obtain a purchaseToken. Do not [acknowledge](https://developer.android.com/google/play/billing/integrate#subscriptions)    the purchaseToken. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement  After calling this method, the payment is confirmed. Callers must durably store their subscriberId before calling this method to ensure their payment is tracked.  Once a purchaseToken to is posted to a subscriberId, the same subscriberId must not be used with another payment method. A different playbilling purchaseToken can be posted to the same subscriberId, in this case the subscription associated with the old purchaseToken will be cancelled. 
         * @summary Set a google play billing purchase token
         * @param {string} subscriberId 
         * @param {string} purchaseToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPlayStoreSubscription(subscriberId: string, purchaseToken: string, options?: any) {
            return SubscriptionsApiFp(configuration).setPlayStoreSubscription(subscriberId, purchaseToken, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {number} level 
         * @param {string} currency 
         * @param {string} idempotencyKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevel(subscriberId: string, level: number, currency: string, idempotencyKey: string, options?: any) {
            return SubscriptionsApiFp(configuration).setSubscriptionLevel(subscriberId, level, currency, idempotencyKey, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} subscriberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriber(subscriberId: string, options?: any) {
            return SubscriptionsApiFp(configuration).updateSubscriber(subscriberId, options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {CreatePayPalBillingAgreementRequest} body 
     * @param {string} subscriberId 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createPayPalPaymentMethod(body: CreatePayPalBillingAgreementRequest, subscriberId: string, userAgent?: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).createPayPalPaymentMethod(body, subscriberId, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriberId 
     * @param {string} [type] 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createPaymentMethod(subscriberId: string, type?: string, userAgent?: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).createPaymentMethod(subscriberId, type, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {GetReceiptCredentialsRequest} body 
     * @param {string} subscriberId 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createSubscriptionReceiptCredentials(body: GetReceiptCredentialsRequest, subscriberId: string, userAgent?: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).createSubscriptionReceiptCredentials(body, subscriberId, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public deleteSubscriber(subscriberId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).deleteSubscriber(subscriberId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} bankTransferType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getBankMandate(bankTransferType: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).getBankMandate(bankTransferType, options)(this.fetch, this.basePath);
    }

    /**
     * Returns all configuration for badges, donation subscriptions, backup subscriptions, and one-time donation ( \"boost\" and \"gift\") minimum and suggested amounts.
     * @summary Subscription configuration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getConfiguration(options?: any) {
        return SubscriptionsApiFp(this.configuration).getConfiguration(options)(this.fetch, this.basePath);
    }

    /**
     * Returns information about the current subscription associated with the provided subscriberId if one exists.  Although it uses [Stripe’s values](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses), the status field in the response is generic, with [Braintree-specific values](https://developer.paypal.com/braintree/docs/guides/recurring-billing/overview#subscription-statuses) mapped to Stripe's. Since we don’t support trials or unpaid subscriptions, the associated statuses will never be returned by the API. 
     * @summary Subscription information
     * @param {string} subscriberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionInformation(subscriberId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionInformation(subscriberId, options)(this.fetch, this.basePath);
    }

    /**
     * Set an originalTransactionId that represents an IAP subscription made with the app store.  To set up an app store subscription: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.apple.com/documentation/storekit/in-app_purchase/) with the App Store    directly via StoreKit and obtain a originalTransactionId. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement 
     * @summary Set app store subscription
     * @param {string} subscriberId 
     * @param {string} originalTransactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public setAppStoreSubscription(subscriberId: string, originalTransactionId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).setAppStoreSubscription(subscriberId, originalTransactionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriberId 
     * @param {string} setupIntentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public setDefaultPaymentMethodForIdeal(subscriberId: string, setupIntentId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).setDefaultPaymentMethodForIdeal(subscriberId, setupIntentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriberId 
     * @param {string} processor 
     * @param {string} paymentMethodToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public setDefaultPaymentMethodWithProcessor(subscriberId: string, processor: string, paymentMethodToken: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).setDefaultPaymentMethodWithProcessor(subscriberId, processor, paymentMethodToken, options)(this.fetch, this.basePath);
    }

    /**
     * Set a purchaseToken that represents an IAP subscription made with Google Play Billing.  To set up a subscription with Google Play Billing: 1. Create a subscriber with `PUT subscriptions/{subscriberId}` (you must regularly refresh this subscriber) 2. [Create a subscription](https://developer.android.com/google/play/billing/integrate) with Google Play Billing    directly and obtain a purchaseToken. Do not [acknowledge](https://developer.android.com/google/play/billing/integrate#subscriptions)    the purchaseToken. 3. `POST` the purchaseToken here 4. Obtain a receipt at `POST /v1/subscription/{subscriberId}/receipt_credentials` which can then be used to obtain the    entitlement  After calling this method, the payment is confirmed. Callers must durably store their subscriberId before calling this method to ensure their payment is tracked.  Once a purchaseToken to is posted to a subscriberId, the same subscriberId must not be used with another payment method. A different playbilling purchaseToken can be posted to the same subscriberId, in this case the subscription associated with the old purchaseToken will be cancelled. 
     * @summary Set a google play billing purchase token
     * @param {string} subscriberId 
     * @param {string} purchaseToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public setPlayStoreSubscription(subscriberId: string, purchaseToken: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).setPlayStoreSubscription(subscriberId, purchaseToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriberId 
     * @param {number} level 
     * @param {string} currency 
     * @param {string} idempotencyKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public setSubscriptionLevel(subscriberId: string, level: number, currency: string, idempotencyKey: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).setSubscriptionLevel(subscriberId, level, currency, idempotencyKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} subscriberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriber(subscriberId: string, options?: any) {
        return SubscriptionsApiFp(this.configuration).updateSubscriber(subscriberId, options)(this.fetch, this.basePath);
    }

}
/**
 * VerificationApi - fetch parameter creator
 * @export
 */
export const VerificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates a session to be able to verify the phone number for account registration. Check the response and submit requested information at PATCH /session/{sessionId} 
         * @summary Creates a new verification session for a specific phone number
         * @param {CreateVerificationSessionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(body: CreateVerificationSessionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createSession.');
            }
            const localVarPath = `/v1/verification/session`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateVerificationSessionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve metadata of the registration verification session with the specified ID 
         * @summary Get a registration verification session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(sessionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getSession.');
            }
            const localVarPath = `/v1/verification/session/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a verification code to the phone number associated with the specified session via SMS or phone call. This endpoint can only be called when the session metadata includes \"allowedToRequestCode = true\" 
         * @summary Request a verification code
         * @param {VerificationCodeRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {string} [acceptLanguage] Ordered list of languages in which the client prefers to receive SMS or voice verification messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVerificationCode(body: VerificationCodeRequest, sessionId: string, userAgent?: string, acceptLanguage?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling requestVerificationCode.');
            }
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling requestVerificationCode.');
            }
            const localVarPath = `/v1/verification/session/{sessionId}/code`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            if (acceptLanguage !== undefined && acceptLanguage !== null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerificationCodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the session with requested information like an answer to a push challenge or captcha. If `requestedInformation` in the response is empty, and `allowedToRequestCode` is `true`, proceed to call `POST /session/{sessionId}/code`. If `requestedInformation` is empty and `allowedToRequestCode` is `false`, then the caller must create a new verification session. 
         * @summary Update a registration verification session
         * @param {UpdateVerificationSessionRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession(body: UpdateVerificationSessionRequest, sessionId: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateSession.');
            }
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling updateSession.');
            }
            const localVarPath = `/v1/verification/session/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateVerificationSessionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a verification code received via SMS or voice for verification 
         * @summary Submit a verification code
         * @param {SubmitVerificationCodeRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode(body: SubmitVerificationCodeRequest, sessionId: string, userAgent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyCode.');
            }
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling verifyCode.');
            }
            const localVarPath = `/v1/verification/session/{sessionId}/code`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAgent !== undefined && userAgent !== null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmitVerificationCodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Initiates a session to be able to verify the phone number for account registration. Check the response and submit requested information at PATCH /session/{sessionId} 
         * @summary Creates a new verification session for a specific phone number
         * @param {CreateVerificationSessionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(body: CreateVerificationSessionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationSessionResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).createSession(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve metadata of the registration verification session with the specified ID 
         * @summary Get a registration verification session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(sessionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationSessionResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).getSession(sessionId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sends a verification code to the phone number associated with the specified session via SMS or phone call. This endpoint can only be called when the session metadata includes \"allowedToRequestCode = true\" 
         * @summary Request a verification code
         * @param {VerificationCodeRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {string} [acceptLanguage] Ordered list of languages in which the client prefers to receive SMS or voice verification messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVerificationCode(body: VerificationCodeRequest, sessionId: string, userAgent?: string, acceptLanguage?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationSessionResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).requestVerificationCode(body, sessionId, userAgent, acceptLanguage, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the session with requested information like an answer to a push challenge or captcha. If `requestedInformation` in the response is empty, and `allowedToRequestCode` is `true`, proceed to call `POST /session/{sessionId}/code`. If `requestedInformation` is empty and `allowedToRequestCode` is `false`, then the caller must create a new verification session. 
         * @summary Update a registration verification session
         * @param {UpdateVerificationSessionRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession(body: UpdateVerificationSessionRequest, sessionId: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationSessionResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).updateSession(body, sessionId, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submits a verification code received via SMS or voice for verification 
         * @summary Submit a verification code
         * @param {SubmitVerificationCodeRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode(body: SubmitVerificationCodeRequest, sessionId: string, userAgent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationSessionResponse> {
            const localVarFetchArgs = VerificationApiFetchParamCreator(configuration).verifyCode(body, sessionId, userAgent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Initiates a session to be able to verify the phone number for account registration. Check the response and submit requested information at PATCH /session/{sessionId} 
         * @summary Creates a new verification session for a specific phone number
         * @param {CreateVerificationSessionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(body: CreateVerificationSessionRequest, options?: any) {
            return VerificationApiFp(configuration).createSession(body, options)(fetch, basePath);
        },
        /**
         * Retrieve metadata of the registration verification session with the specified ID 
         * @summary Get a registration verification session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(sessionId: string, options?: any) {
            return VerificationApiFp(configuration).getSession(sessionId, options)(fetch, basePath);
        },
        /**
         * Sends a verification code to the phone number associated with the specified session via SMS or phone call. This endpoint can only be called when the session metadata includes \"allowedToRequestCode = true\" 
         * @summary Request a verification code
         * @param {VerificationCodeRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {string} [acceptLanguage] Ordered list of languages in which the client prefers to receive SMS or voice verification messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestVerificationCode(body: VerificationCodeRequest, sessionId: string, userAgent?: string, acceptLanguage?: string, options?: any) {
            return VerificationApiFp(configuration).requestVerificationCode(body, sessionId, userAgent, acceptLanguage, options)(fetch, basePath);
        },
        /**
         * Updates the session with requested information like an answer to a push challenge or captcha. If `requestedInformation` in the response is empty, and `allowedToRequestCode` is `true`, proceed to call `POST /session/{sessionId}/code`. If `requestedInformation` is empty and `allowedToRequestCode` is `false`, then the caller must create a new verification session. 
         * @summary Update a registration verification session
         * @param {UpdateVerificationSessionRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSession(body: UpdateVerificationSessionRequest, sessionId: string, userAgent?: string, options?: any) {
            return VerificationApiFp(configuration).updateSession(body, sessionId, userAgent, options)(fetch, basePath);
        },
        /**
         * Submits a verification code received via SMS or voice for verification 
         * @summary Submit a verification code
         * @param {SubmitVerificationCodeRequest} body 
         * @param {string} sessionId 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCode(body: SubmitVerificationCodeRequest, sessionId: string, userAgent?: string, options?: any) {
            return VerificationApiFp(configuration).verifyCode(body, sessionId, userAgent, options)(fetch, basePath);
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * Initiates a session to be able to verify the phone number for account registration. Check the response and submit requested information at PATCH /session/{sessionId} 
     * @summary Creates a new verification session for a specific phone number
     * @param {CreateVerificationSessionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public createSession(body: CreateVerificationSessionRequest, options?: any) {
        return VerificationApiFp(this.configuration).createSession(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve metadata of the registration verification session with the specified ID 
     * @summary Get a registration verification session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public getSession(sessionId: string, options?: any) {
        return VerificationApiFp(this.configuration).getSession(sessionId, options)(this.fetch, this.basePath);
    }

    /**
     * Sends a verification code to the phone number associated with the specified session via SMS or phone call. This endpoint can only be called when the session metadata includes \"allowedToRequestCode = true\" 
     * @summary Request a verification code
     * @param {VerificationCodeRequest} body 
     * @param {string} sessionId 
     * @param {string} [userAgent] 
     * @param {string} [acceptLanguage] Ordered list of languages in which the client prefers to receive SMS or voice verification messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public requestVerificationCode(body: VerificationCodeRequest, sessionId: string, userAgent?: string, acceptLanguage?: string, options?: any) {
        return VerificationApiFp(this.configuration).requestVerificationCode(body, sessionId, userAgent, acceptLanguage, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the session with requested information like an answer to a push challenge or captcha. If `requestedInformation` in the response is empty, and `allowedToRequestCode` is `true`, proceed to call `POST /session/{sessionId}/code`. If `requestedInformation` is empty and `allowedToRequestCode` is `false`, then the caller must create a new verification session. 
     * @summary Update a registration verification session
     * @param {UpdateVerificationSessionRequest} body 
     * @param {string} sessionId 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public updateSession(body: UpdateVerificationSessionRequest, sessionId: string, userAgent?: string, options?: any) {
        return VerificationApiFp(this.configuration).updateSession(body, sessionId, userAgent, options)(this.fetch, this.basePath);
    }

    /**
     * Submits a verification code received via SMS or voice for verification 
     * @summary Submit a verification code
     * @param {SubmitVerificationCodeRequest} body 
     * @param {string} sessionId 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verifyCode(body: SubmitVerificationCodeRequest, sessionId: string, userAgent?: string, options?: any) {
        return VerificationApiFp(this.configuration).verifyCode(body, sessionId, userAgent, options)(this.fetch, this.basePath);
    }

}
